<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>明日方舟 鸡翅小羊双人CE-5</title>
      <link href="2021/03/02/aknights_1/"/>
      <url>2021/03/02/aknights_1/</url>
      
        <content type="html"><![CDATA[<p>摸鱼使我快乐.jpg</p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=204442921&bvid=BV12h411k7N9&cid=305192999&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 摸鱼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 明日方舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件权限</title>
      <link href="2021/02/28/LinuxFilePermission/"/>
      <url>2021/02/28/LinuxFilePermission/</url>
      
        <content type="html"><![CDATA[<p><a href="http://cn.linux.vbird.org/">鸟哥的Linux私房菜</a>看着有点意思</p><p>因为之前配环境装东西的时候因为文件的权限问题搞了好久，看了鸟哥的书之后整理一下</p><h2 id="1-用户和用户组"><a href="#1-用户和用户组" class="headerlink" title="1.用户和用户组"></a>1.用户和用户组</h2><p>因为Linux是个多人多任务的系统，所以对文件权限的管理就非常的重要</p><p>用户和用户组可以解决：</p><ul><li>只属于自己的文件不想给别人看</li><li>同一组的文件只能在组内共享，别人看不了</li></ul><p>的问题</p><p>这里有三个概念：</p><ul><li>用户（User）</li><li>用户组（Group）</li><li>其他人（Other）</li></ul><p>Linux中任何一个文件都有这三种身份的权限</p><p>举一个栗子，用户相当于akane，用户组相当于akane家，akane的兄弟姐妹也是不同的用户，而akane和ta的兄弟姐妹就组成了一个用户组。akane的小金库不想和兄弟姐妹共享，那么这个小金库就只对akane开放，对于akane所在的用户组中的其他用户都是不开放的；而不属于akane所在组的用户就属于others，akane的小金库对他们也是不开放的；而akane家的冰箱对于akane和ta的兄弟姐妹都是开放的，大家可以自己拿自己想吃的东西，但是对于others是不开放的（比如说他们不希望别人随便来他们家冰箱找吃的）</p><p>但是全能的神可以不管akane或者ta的兄弟姐妹想不想把东西给他看，对世间万物（?）都可以随便拿随便看，在Linux中这个全能的神就是root</p><p>Linux的文件权限差不多就类似于上面栗子的玩意</p><h2 id="2-Linux文件属性"><a href="#2-Linux文件属性" class="headerlink" title="2.Linux文件属性"></a>2.Linux文件属性</h2><p>在terminal使用命令<code>su -</code>切换到<code>root</code>身份后，输入命令<code>ls -al</code>，可以看到类似于下面的Linux文件的详细信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls -al</span><br><span class="line">total 156</span><br><span class="line">drwxr-x---   4    root   root     4096   Sep  8 14:06 .</span><br><span class="line">drwxr-xr-x  23    root   root     4096   Sep  8 14:21 ..</span><br><span class="line">-rw-------   1    root   root     1474   Sep  4 18:27 anaconda-ks.cfg</span><br><span class="line">-rw-------   1    root   root      199   Sep  8 17:14 .bash<span class="emphasis">_history</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root       24   Jan  6  2007 .bash_</span>logout</span><br><span class="line">-rw-r--r--   1    root   root      191   Jan  6  2007 .bash<span class="emphasis">_profile</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root      176   Jan  6  2007 .bashrc</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root      100   Jan  6  2007 .cshrc</span></span><br><span class="line"><span class="emphasis">drwx------   3    root   root     4096   Sep  5 10:37 .gconf      </span></span><br><span class="line"><span class="emphasis">drwx------   2    root   root     4096   Sep  5 14:09 .gconfd</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root    42304   Sep  4 18:26 install.log &lt;=范例说明处</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root     5661   Sep  4 18:25 install.log.syslog</span></span><br><span class="line"><span class="emphasis">[<span class="string">    1   </span>][<span class="symbol">  2 </span>][<span class="string">   3  </span>][<span class="symbol">  4 </span>][<span class="string">    5   </span>][<span class="symbol">     6     </span>][<span class="string">       7          </span>]</span></span><br><span class="line"><span class="emphasis">[<span class="string">  权限  </span>][<span class="symbol">link</span>][<span class="string">user</span>][<span class="symbol">group</span>][<span class="string">文件容量</span>][<span class="symbol">  修改日期 </span>][<span class="string">      文件名        </span>]</span></span><br></pre></td></tr></table></figure><p>我们拿出第一个范例来看</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>对于范例处，也就是<code>-rw-r--r--</code>的内容</p><p>总共有十个字符，一般这样划分：<code>-/rw-/r--/r--</code></p><p>第一个字母表示的是该文件的类型，是文件还是文件夹还是链接文件等，这里介绍主要的几种</p><ul><li><code>d</code>：文件夹</li><li><code>-</code>：普通文件</li><li><code>l</code>：链接文件，也就是windows里面的快捷方式</li></ul><p>还有其他的文件类型，可以去看看鸟哥写的（懒狗发言）</p><p>之后的三个字符一组，分别表示的是：</p><ul><li>文件拥有者对文件的读、写、执行权限</li><li>文件所属用户组对文件的读、写、执行权限</li><li>其他人对该文件的读、写、执行权限</li></ul><p>在这个例子里：</p><ul><li>文件拥有者的读、写、执行权限为：<code>rw-</code></li><li>文件所属用户组对文件的读、写、执行权限为：<code>r--</code></li><li>其他人对该文件的读、写、执行权限为：<code>r--</code></li></ul><p>这三个字符是有固定位置的，分别为<code>rwx</code>，其中<code>r</code>表示可读，<code>w</code>表示可写，<code>x</code>表示可执行（对于文件和文件夹这三个字符的表示含义又有一些不同，之后会讲到）</p><p>如果没有对应的权限的话，该位置就会变成<code>-</code></p><p>例如，如果该用户对此文件有读和执行的权限，没有写的权限，则表示为<code>r-x</code></p><p>对于上面这个栗子，可以看出：</p><ul><li>文件拥有者对该文件可读可写（<code>rw-</code>）</li><li>文件所属用户组对该文件只可读（<code>r--</code>）</li><li>其他用户对该文件只可读（<code>r--</code>）</li></ul><p>举一个别的栗子，假设一个文件的权限部分写的是<code>drwxr-xr--</code>，我们可以做的事有：</p><ul><li>划分成<code>d/rwx/r-x/r--</code></li><li>第一个字符为<code>d</code>，说明这个文件是个文件夹</li><li>第一组三个字符为<code>rwx</code>，说明该文件所属的用户对该文件可读可写可执行</li><li>第二组三个字符为<code>r-x</code>，说明该文件所属用户组对该文件可读可执行</li><li>第三组三个字符为<code>r--</code>，说明其他用户对该文件只可读</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之后几栏分别表示什么呢</p><ul><li>十个字符后面的数字，也就是第二栏，表示的是链接数，说明有多少个文件名链接到这个结点</li><li>第三栏：该文件的拥有者账号</li><li>第四栏：该文件所属的用户组</li><li>第五栏：文件大小</li><li>第六栏：文件的创建日期或最近修改日期</li><li>第七栏：文件名</li></ul><h2 id="3-修改文件属性和权限"><a href="#3-修改文件属性和权限" class="headerlink" title="3.修改文件属性和权限"></a>3.修改文件属性和权限</h2><p><strong>警告</strong>：<code>chgrp</code>、<code>chown</code>和<code>chmod</code>只能在<code>root</code>下执行</p><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>即：change group，修改文件所属的用户组</p><p>一般格式：<code>chgrp [-R] groupname dirname/filename</code></p><p>其中<code>[-R]</code>表示进行递归的修改，用于修改目录所属用户组的时候，使其子目录和该目录下的文件也变成这个用户组的</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>即：change owner，修改文件所属用户</p><p>一般格式：<code>chown [-R] username dirname/filename</code></p><p>如果想同时修改文件所属的用户和用户组，也可以使用<code>chown</code>，格式为<code>chown [-R] username:groupname dirname/filename</code></p><p>也可以用<code>chown</code>来修改文件所属的用户组：<code>chown [-R] :groupname dirname/filename</code></p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>这个命令可以用来修改文件对于拥有者、所属用户组以及其他用户的读写执行权限</p><p>格式为：<code>chmod [-R] xyz dirname/filename</code></p><p>那么，<code>xyz</code>是什么呢</p><p>还记得之前三个三个分组的<code>rwx</code>吗，<code>r</code>表示4，<code>w</code>表示2，<code>x</code>表示1，对应用户/用户组/其他人拥有的权限对应的数字加起来得到的值，就是<code>chmod</code>命令中写的数字<code>xyz</code>了</p><p>举一个栗子，如果我们希望把一个文件的读写权限改成<code>rwx/r-x/r--</code>，那么对应的数字就是<code>754</code>，对应的命令就是<code>chmod 754 filename</code></p><p>如果写的命令是<code>chmod 777 filename</code>，就说明让这个文件对所有的用户可读可写可执行</p><h4 id="符号方式修改"><a href="#符号方式修改" class="headerlink" title="符号方式修改"></a>符号方式修改</h4><p>除了刚刚那种直接写数字的方法，还可以用符号来修改文件的权限</p><p>我们用<code>u</code>表示<code>user</code>，<code>g</code>表示<code>group</code>，<code>o</code>表示<code>other</code>，<code>a</code>表示全部</p><p><code>+</code>表示增加权限，<code>-</code>表示取消权限，<code>=</code>表示设置</p><p>希望看了下面的栗子能看出来它是怎么用的（狗头）</p><ul><li><p><code>chmod u=rwx,g=rw- filename</code>：文件拥有者权限设置为可读可写可执行，文件所属用户组权限设置为可读可写</p></li><li><p><code>chmod o-x filename</code>：去除其他用户对文件的可执行权限</p></li><li><p><code>chmod a+w filename</code>：为所有的用户加上对文件的可写权限</p></li></ul><h2 id="4-文件与目录的权限意义"><a href="#4-文件与目录的权限意义" class="headerlink" title="4.文件与目录的权限意义"></a>4.文件与目录的权限意义</h2><p>对文件：</p><ul><li><code>r</code>：可以读取文件内容</li><li><code>w</code>：可以编辑、修改、删除文件内容，但是<strong>不可以删除文件</strong></li><li><code>x</code>：该文件可以被系统执行</li></ul><p>对文件夹：</p><ul><li><code>r</code>：可以查询该目录下的文件名数据（但是如果没有<code>x</code>的话，就仅限于查看文件名）</li><li><code>w</code>：可以新建、删除、移动、重命名文件/文件夹</li><li><code>x</code>：<strong>可以进入这个文件夹作为你的工作目录</strong>，不然就只能在外面看看（如果这个文件夹对你来说没有<code>x</code>的话，你是<code>cd</code>不进去的）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Jupyterhub架构</title>
      <link href="2021/02/26/jupyterhub_1/"/>
      <url>2021/02/26/jupyterhub_1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于tornado"><a href="#1-关于tornado" class="headerlink" title="1.关于tornado"></a>1.关于tornado</h2><p>由于jupyterhub是非常典型的tornado应用结构，因此需要一些关于tornado的知识 <a href="https://tornado-zh.readthedocs.io/zh/latest/guide/structure.html">tornado官方文档链接</a></p><blockquote><p>A Tornado web application generally consists of one or more RequestHandler subclasses, an Application object with routes incoming requests to handlers, and a main() function to start the server</p></blockquote><p>一个tornado应用主要包括三部分：</p><ul><li>一个<code>Application</code>对象：用于全局配置，将请求的路由映射到对应的handler</li><li>多个<code>RequestHandler</code>子类：用于执行对应url的处理逻辑</li><li>一个启动服务的<code>main()</code>函数</li></ul><p><img src="/img/tornado.jpg" alt="tornado"></p><h3 id="Application对象"><a href="#Application对象" class="headerlink" title="Application对象"></a>Application对象</h3><p><code>Application</code>对象负责全局配置，将请求的路由映射到对应的handler，因此需要传递给<code>Application</code>一个路由表（<code>URLSpec</code> object list）用于进行路由的配置</p><p><a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings">官方Application configuration文档</a></p><h4 id="URLSpec"><a href="#URLSpec" class="headerlink" title="URLSpec"></a>URLSpec</h4><p>一个<code>URLSpec</code>的栗子：<code>url(r&quot;/story/([0-9]+)&quot;, StoryHandler, dict(db=db), name=&quot;story&quot;)</code></p><p>主要包含四个部分：**(matcher,** <strong>target,</strong> <strong>[target_kwargs],</strong> <strong>[name])</strong></p><ul><li>正则表达式（必写）：用于与url进行匹配，采用first matching rule</li><li>处理类（必写）：一个<code>RequestHandler</code>的子类，实现处理逻辑</li><li>dict（可选）：作为初始参数传给<code>RequestHandler.initialize()</code></li><li>name（可选）：允许其被<code>RequestHandler.reverse_url</code>使用</li></ul><p>对<code>Application</code>进行配置的时候不仅可以配置路由表，还可以配置其他的信息 </p><p>要添加额外的handlers，可以使用<code>application.add_handlers()</code>，添加额外的路由信息</p><h4 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h4><p>Settings主要用于自定义tornado的很多方面，这里只展示了部分，关于全部<code>settings</code>的内容请看<a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings">官方文档</a></p><ul><li>General settings</li><li>Authentication and security settings<ul><li><code>cookie_secret</code>：用于对cookies进行签名 <a href="https://blog.csdn.net/adley_app/article/details/80734247">cookie防篡改机制</a></li><li><code>login_url</code>：如果用户没有登录，<code>authenticated</code>装饰器将会重定向到这个url。可以通过重写<code>RequestHandler.get_login_url</code>进行自定义</li></ul></li><li>Template settings<ul><li><code>template_path</code>：包含template文件的路径</li></ul></li><li>Static file settings<ul><li><code>static_path</code>：静态文件所在文件夹</li><li><code>static_url_prefix</code>：静态文件的url前缀</li></ul></li></ul><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>一个将URLSpec list传入<code>Application</code>进行配置的栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app = Application([</span><br><span class="line">    url(<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    url(<span class="string">r&quot;/story/([0-9]+)&quot;</span>, StoryHandler, <span class="built_in">dict</span>(db=db), name=<span class="string">&quot;story&quot;</span>)</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>我们还可以加入自己的settings</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">settings = <span class="built_in">dict</span>(...)</span><br><span class="line">app = Application([</span><br><span class="line">    url(<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    url(<span class="string">r&quot;/story/([0-9]+)&quot;</span>, StoryHandler, <span class="built_in">dict</span>(db=db), name=<span class="string">&quot;story&quot;</span>)</span><br><span class="line">    ],settings)</span><br></pre></td></tr></table></figure><h3 id="RequestHandler子类"><a href="#RequestHandler子类" class="headerlink" title="RequestHandler子类"></a>RequestHandler子类</h3><blockquote><p>The main entry point for a handler subclass is a method named after the HTTP method being handled: <code>get()</code>, <code>post()</code>, etc. Each handler may define one or more of these methods to handle different HTTP actions.</p></blockquote><p>RequestHandler的子类主要用来处理http请求，进行对应的操作，主要需要实现的有<code>get</code>和<code>post</code>方法</p><h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><p><code>render</code>方法可以使用<code>template</code>用对应的参数进行渲染，<code>write</code>方法则不使用<code>template</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFormHandler</span>(<span class="params">tornado.web.RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.render(<span class="string">&#x27;index.html&#x27;</span>, message=file_url)</span><br></pre></td></tr></table></figure><h4 id="处理输入请求"><a href="#处理输入请求" class="headerlink" title="处理输入请求"></a>处理输入请求</h4><p><code>self.request</code>可以访问到当前的请求对象，如果是通过HTML表单格式请求的数据会被解析，且能够通过<code>get_query_argument</code>和<code>get_body_argument</code>进行访问</p><p><a href="https://tornado-zh.readthedocs.io/zh/latest/httputil.html#tornado.httputil.HTTPServerRequest">HTTPServerRequest完整属性列表</a></p><h4 id="RequestHandler的调用序列"><a href="#RequestHandler的调用序列" class="headerlink" title="RequestHandler的调用序列"></a>RequestHandler的调用序列</h4><ul><li>创建一个新的<code>RequestHandler</code></li><li>调用<code>initialize()</code>方法（还记得前面传递的参数吗）</li><li>调用<code>prepare()</code>方法</li><li>调用某个HTTP method：GET/POST/PUT</li><li>结束时调用<code>on_finish()</code>方法</li></ul><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>大概了解了<code>Application</code>以及<code>RequestHandler</code>子类之后，就可以写出一个最简单的hello world了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">tornado.web.RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span>():</span></span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([</span><br><span class="line">        (<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><h3 id="认证和安全"><a href="#认证和安全" class="headerlink" title="认证和安全"></a>认证和安全</h3><p>刚刚提到，在给<code>application</code>传递参数时，有一个选项为<code>cookie_secret</code>，该密钥是用来对cookies进行签名防止伪造的，这里提一下tornado的认证与安全，jupyterhub也会使用到</p><p>进行签名后的cookies会包含了编码后得cookie值、时间戳以及一个HMAC signature，<code>get_secure_cookie</code>方法会对其值进行验证，如果不通过则会返回<code>None</code>；若需要使用<code>cookie_secret</code>对cookie进行签名，则可以使用<code>set_secure_cookie</code>方式</p><p>在<code>RequestHandler</code>的子类，即我们自己编写的<code>Handler</code>中，有时我们需要确认实现用户认证，就需要复写请求处理函数<code>get_current_user</code>来对当前用户进行判断，比如可以基于cookie的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseHandler</span>(<span class="params">tornado.web.RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current_user</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.get_secure_cookie(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">BaseHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.current_user:</span><br><span class="line">            self.redirect(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        name = tornado.escape.xhtml_escape(self.current_user)</span><br><span class="line">        self.write(<span class="string">&quot;Hello, &quot;</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span>(<span class="params">BaseHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;Name: &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;&lt;input type=&quot;submit&quot; value=&quot;Sign in&quot;&gt;&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.set_secure_cookie(<span class="string">&quot;user&quot;</span>, self.get_argument(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">        self.redirect(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    (<span class="string">r&quot;/login&quot;</span>, LoginHandler),</span><br><span class="line">], cookie_secret=<span class="string">&quot;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-Jupyterhub基本架构"><a href="#2-Jupyterhub基本架构" class="headerlink" title="2.Jupyterhub基本架构"></a>2.Jupyterhub基本架构</h2><p>对tornado应用的结构有了初步的了解后，我们可以开始对Jupyterhub的架构一探究竟了</p><p>Jupyterhub的有几个主要的组成部分</p><ul><li>hub（tornado application）</li><li>proxy：面向用户的部分，使用动态代理来调整HTTP对hub或单用户的notebook服务发送的请求</li><li>notebook server</li></ul><h3 id="Hub"><a href="#Hub" class="headerlink" title="Hub"></a>Hub</h3><blockquote><p><strong>Hub</strong> (Python/Tornado): manages user accounts, authentication, and coordinates Single User Notebook Servers using a Spawner.</p></blockquote><p>hub的主要功能：</p><ul><li>对登录用户进行认证（Authenticator）</li><li>保存用户、service等数据（Database）</li><li>为用户分配单用户notebook server（Spawner）</li></ul><h4 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h4><blockquote><p>The <strong>Authenticator</strong> is the mechanism for authorizing users to use the Hub and single user notebook servers.</p></blockquote><p>当用户进行登录时，会调用配置的<code>Authenticator</code>的<code>authenticate</code>方法对用户进行认证（例如默认使用的是<code>PAMAuthenticator</code>，其<code>authenticate</code>方法中会获取用户输入的用户名和密码进行认证，也可使用别的<code>authenticator</code>进行认证）</p><p>如果需要使用自己写的<code>authenticator</code>，写好之后，可以在<code>jupyterhub_config.py</code>文件中进行设置：</p><p><code>c.JupyterHub.authenticator_class = &#39;yourpackage:YourAuthenticator&#39;</code></p><p>要查看关于<code>Authenticator</code>的源码，可以查看一下<code>jupyterhub/jupyterhub/auth.py</code>中的内容</p><h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><blockquote><p>JupyterHub uses a database to store information about users, services, and other data needed for operating the Hub.</p></blockquote><p>话不多说，直接谷歌翻译</p><h4 id="Spawner"><a href="#Spawner" class="headerlink" title="Spawner"></a>Spawner</h4><blockquote><p>A <strong>Spawner</strong> starts each single-user notebook server</p></blockquote><p>当用户登录后，如果对应的notebook server没有启动，可以通过<code>/spawn</code>页面中的表单提交选项，利用spawner去启动notebook server（<code>Spawner.start</code>）</p><p>spawn，谷歌翻译的意思是<em>产卵</em>，可能这样会好理解一点</p><p>通过spawner启动了对应的notebook server后，会得到该server的ip以及port，将会被注册到proxy的路由表中，这样当用户下一次要使用该server的时候，proxy就会根据这个ip以及port，将该用户直接跳转到这个notebook server对应的地址，对应jupyterhub中的url格式为<code>/url/:username/:servername</code>（<a href="https://jupyterhub.readthedocs.io/en/stable/reference/urls.html#user-username-servername">jupyterhub的URL模式</a>）</p><p>当spawner启动之后，会通过<code>Spawner.poll</code>来确认spawner是不是还或者，如果返回的是<code>None</code>，就说明它依然健在，否则可能出事了</p><p>如果要停下spawner的话，可以使用<code>Spawner.stop</code></p><p>更多有关的代码可以查看<code>jupyterhub/jupyterhub/spawner.py</code>中的内容</p><p>和<code>Authenticator</code>同理，如果想要使用自己写的<code>Spawner</code>，可以通过修改配置文件<code>jupyterhub_config.py</code>来实现：</p><p>``c.JupyterHub.spawner_class = ‘yourpackage:YourSpawner’`</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><blockquote><p>the public facing part of JupyterHub that uses a dynamic proxy to route HTTP requests to the Hub and Single User Notebook Servers. configurable http proxy(node-http-proxy) is the default proxy</p></blockquote><p>还记得前面说到的启动server后会返回ip以及port并将其注册到proxy的路由表中吗，proxy是hub的与用户进行交互的部分，能够根据路由表中的信息，使用动态代理来调整HTTP对hub或单用户的notebook服务发送的请求</p><p>默认的proxy使用的是<a href="https://github.com/jupyterhub/configurable-http-proxy">configurable http proxy</a>（不知道是不是网络问题文档一直打不开我裂开来）</p><h3 id="Notebook-server"><a href="#Notebook-server" class="headerlink" title="Notebook server"></a>Notebook server</h3><blockquote><p>a dedicated, single-user, Jupyter Notebook server is started for each user on the system when the user logs in. The object that starts the single-user notebook servers is called a <strong>Spawner</strong>.</p></blockquote><p>当用户登录了之后，就会启动对应的单用户jupyterhub notebook server，对应的功能描述看看<a href="https://jupyter.org/">文档</a>吧</p><h3 id="子系统的交互"><a href="#子系统的交互" class="headerlink" title="子系统的交互"></a>子系统的交互</h3><img src="https://img-blog.csdnimg.cn/20200708202115603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTE1MzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /><p>知道了上面三个Jupyterhub的基本组成部分（三大子系统），可以了解一下它们之间是怎么交互的啦</p><p>基本的流程大致长这个样子（建议结合上面官方的架构图进行食用）：</p><ul><li><p>hub产生proxy（可以参见源码<code>jupyterhub/jupyterhub/app.py</code>中<code>init_proxy</code>的部分），proxy默认将请求发送给hub</p></li><li><p>由于hub本质上是一个tornado application，那么从proxy中拿到的request全部都要由hub中注册的<code>requestHandler</code>的子类进行处理，例如：</p><ul><li>进行用户登录，并对用户的身份进行认证（<strong>Authenticator</strong>），用户的信息会被保存在<strong>database</strong>中</li><li>启动<strong>spawner</strong>生成<strong>notebook server</strong>，并将其注册到proxy的路由表中，等下一次要用的时候可以直接跳转到对应的server（**/user/[name]/**）</li><li>notebook server也可以通过hub中的authenticator等对用户身份进行认证等（**/api/auth**）</li></ul><p>…之类的操作</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>某些关于security settings的内容</p><h4 id="SSL-encryption"><a href="#SSL-encryption" class="headerlink" title="SSL encryption"></a>SSL encryption</h4><blockquote><p>You should not run JupyterHub without SSL encryption on a public network.</p></blockquote><p>SSL（Secure Sockets Layer）用于保障在网络上数据传输的安全，利用数据加密（Encryption）来确保数据在网络上传输过程中不会被窃取或监听</p><p>关于SSL协议的运行机制请看<a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">这篇</a></p><p>由于数据传输过程之前需要握手，网站需要向浏览器发送SSL证书，用于支持HTTPS网站的身份证明，其中包含了网站域名、证书有效期以及用于加密传输密码的公钥的信息</p><p>Jupyterhub需要使用SSL进行传输，因此需要配置SSL证书的信息，在<code>jupyterhub_config.py</code>文件中可以配置<code>ssl_key</code>以及<code>ssl_cert</code>的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.JupyterHub.ssl_key = <span class="string">&#x27;/path/to/my.key&#x27;</span></span><br><span class="line">c.JupyterHub.ssl_cert = <span class="string">&#x27;/path/to/my.cert&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="cookie-secret"><a href="#cookie-secret" class="headerlink" title="cookie secret"></a>cookie secret</h4><p><a href="https://blog.csdn.net/adley_app/article/details/80734247">关于cookie防篡改机制</a></p><blockquote><p>The cookie secret is an encryption key, used to encrypt the browser cookies which are used for authentication</p></blockquote><p>可以看出，cookie secret主要是用于对用户的cookie进行加密，同时防止用户对cookie进行篡改从而伪造成别人（还记得前面讲到的<code>Application</code>中<code>setting</code>参数中可以传入的<code>cookie_secret</code>吗，jupyterhub中也可以传入<code>cookie_secret</code>，同样也用于在<code>set_secure_cookie</code>以及<code>get_secure_cookie</code>中对用户进行认证或添加cookie）</p><p>在jupyterhub中，有三种方式可以生成和配置<code>cookie secret</code>，这里介绍其中的一种，更多的可以查看官方<a href="https://jupyterhub.readthedocs.io/en/stable/getting-started/security-basics.html?highlight=ssl#cookie-secret">介绍</a></p><p>同样还是配置<code>jupyterhub_config.py</code>文件，<code>c.JupyterHub.cookie_secret = bytes.fromhex(&#39;64 CHAR HEX STRING&#39;)</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/img/image-20210227222005582.png" alt="image-20210227222005582"></p><p>自己把之前那一张官方的架构图扩大了，希望有一点帮助吧</p><p>之后会继续写关于jupyterhub启动流程的东西，还是会扯到上面讲的很多内容</p><p>啊（懒狗叹气.jpg）</p>]]></content>
      
      
      <categories>
          
          <category> JupyterHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JupyterHub </tag>
            
            <tag> tornado </tag>
            
            <tag> cookie secret </tag>
            
            <tag> ssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo安装+butterfly主题配置</title>
      <link href="2021/02/22/HexoConfig/"/>
      <url>2021/02/22/HexoConfig/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=2d5c8b14-1a70-4516-a004-1962b3a68783&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">hexo史上最全搭建教程</a></li><li><a href="https://blog.csdn.net/qq_31880107/article/details/86688467">windows下Hexo博客搭建过程</a></li><li><a href="https://hexo.io/docs/">hexo官方文档</a></li><li><a href="https://valine.js.org/">Valine官方文档</a></li><li><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo博客搭建之在文章中插入图片</a></li></ul><h2 id="1-Hexo安装"><a href="#1-Hexo安装" class="headerlink" title="1.Hexo安装"></a>1.Hexo安装</h2><p>需要事先安装好：</p><ul><li><p>nodejs，可以使用<code>node -v</code>查看是否已经安装</p></li><li><p>git，可以使用<code>git --version</code>查看是否已经安装</p><p>一般下载完之后还需要将其配置到系统路径中，参考<a href="https://blog.csdn.net/weixin_43803924/article/details/104606989">这一篇</a></p></li></ul><p>确保都安装好后：</p><ul><li><p>新建一个空文件夹，<code>cd</code>进去</p></li><li><p>可以右键打开<code>powershell</code>，也可以使用<code>Git Bash</code>，按顺序执行以下命令</p><ul><li><p><code>npm install -g hexo</code></p></li><li><p><code>hexo init 你的文件夹名</code></p><p>初始化成功后会显示<code>Start blogging with Hexo!</code>，同时空文件夹下会多出一个你刚刚命名的文件夹</p><p><img src="/img/image-20210222173111226.png" alt="image-20210222173111226"></p></li></ul><center>输入的是hexo init akaneovoBlog</center></li><li><p><code>cd</code>进入到新创建的文件夹中，按顺序执行以下命令</p><ul><li><code>npm install</code></li><li><code>hexo g</code>或<code>hexo generate</code></li><li><code>hexo server</code></li></ul></li><li><p>此时会显示<code>Hexo is running at http://localhost:4000/</code>，可以打开浏览器查看，若展示出默认的博客，则安装成功</p></li></ul><h2 id="2-将本地博客托管到Github上"><a href="#2-将本地博客托管到Github上" class="headerlink" title="2.将本地博客托管到Github上"></a>2.将本地博客托管到Github上</h2><p>需要更改配置文件<code>_config.yml</code>，以上面的文件夹为例，其地址为：</p><p><img src="/img/image-20210222173540149.png" alt="image-20210222173540149"></p><p>其中的<code>myBlog</code>即一开始创建的空文件夹，<code>akaneovoBlog</code>为<code>hexo init</code>时创建的文件夹，</p><p><strong>不要用txt直接打开它，最好用vscode之类的文本编辑器</strong></p><p>修改<code>_config.yml</code>文件中的<code>deploy</code>，改成图示形式：</p><p><img src="/img/image-20210222173755509.png" alt="image-20210222173755509"></p><p><strong>冒号后面记得带一个空格</strong></p><p>其中<code>repository</code>为自己的github仓库地址，也可以写成http的，但是不知道为啥我用了半天之后突然间<code>hexo d</code>就报错了，改成上面这个格式的就好了</p><p>保存之后安装<code>hexo-deployer-git</code>插件：<code>npm install hexo-deployer-git --save</code></p><p>之后每次修改本地博客并上传到github，都要执行如下代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generator # 或简写为hexo g</span><br><span class="line">hexo deploy # 或简写为hexo d</span><br></pre></td></tr></table></figure><p>如果只是在本地更改了文件在本地进行测试：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>托管到github上面之后，可以通过<code>xxx.github.io</code>查看自己的个人博客，或者通过自己和Github Pages绑定的域名进行查看</p><h2 id="3-配置butterfly主题"><a href="#3-配置butterfly主题" class="headerlink" title="3.配置butterfly主题"></a>3.配置butterfly主题</h2><p>u1s1，butterfly比之前看到的anatole功能真的多了好多，文档也多了超级多</p><p>看<a href="https://butterfly.js.org/">官方文档</a>来配置就够啦</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Pages与个人域名绑定</title>
      <link href="2021/02/22/BlogConfig/"/>
      <url>2021/02/22/BlogConfig/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="https://cyclechen.me/2019/03/13/2019-03-13-setup-github-page-personal-with-godaddy/">github page 绑定 GoDaddy 的个人域名</a></p><h2 id="1-GoDaddy买一个域名"><a href="#1-GoDaddy买一个域名" class="headerlink" title="1.GoDaddy买一个域名"></a>1.GoDaddy买一个域名</h2><p>有手就行</p><h2 id="2-github-repository配置"><a href="#2-github-repository配置" class="headerlink" title="2.github repository配置"></a>2.github repository配置</h2><h3 id="新建一个github仓库"><a href="#新建一个github仓库" class="headerlink" title="新建一个github仓库"></a>新建一个github仓库</h3><ul><li><p>命名格式为<code>[随便一个名字].github.io</code>，例如<code>akaneovo.github.io</code>（之后都是拿这个作为例子）</p></li><li><p>设置为public，不然后面的github pages没有办法选择theme</p></li><li><p>选择<code>add a README file</code></p><p><img src="/img/image-20210221222049663.png" alt="image-20210221222049663.png"></p></li></ul><h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><ul><li><p>点击<code>Settings</code>，下拉到<code>GitHub Pages</code></p></li><li><p>点击<code>Change theme</code>选择一个Jekyll theme</p><p>如果之前自己写了<code>html</code>文件之类的还是要选，不然好像会404</p></li><li><p><code>Custom domain</code>里面填自己购买的域名</p><p><img src="/img/image-20210221223140725.png" alt="image-20210221223140725.png"></p></li></ul><h2 id="3-GoDaddy配置"><a href="#3-GoDaddy配置" class="headerlink" title="3.GoDaddy配置"></a>3.GoDaddy配置</h2><ul><li><p>选择<code>DNS</code></p><p><img src="/img/image-20210221223838993.png" alt="image-20210221223838993.png"></p></li></ul><ul><li><p>在<code>记录</code>部分添加两种记录</p><p><img src="/img/image-20210221223953867.png" alt="image-20210221223953867"></p><p>其中github IP可以在<a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">这里</a>获取</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>这四个随便哪一个都行</p></li></ul><h2 id="4-DNS设置"><a href="#4-DNS设置" class="headerlink" title="4.DNS设置"></a>4.DNS设置</h2><ul><li><p>打开<a href="https://www.dnspod.cn注册一个账号/">https://www.dnspod.cn注册一个账号</a></p></li><li><p>选择DNS解析，把自己买的域名添加进去</p></li><li><p>会提示GoDaddy的域名服务器和腾讯云的域名服务器不一样，打开GoDaddy域名配置的地方，使用自定义域名服务器</p><p><img src="/img/image-20210221224432853.png" alt="image-20210221224432853"></p></li><li><p>两个域名都复制腾讯云提示的域名服务器的地址，然后保存</p></li><li><p>点击添加的域名，类似于GoDaddy的配置，添加两条记录</p><p><img src="/images/image-20210221224612240.png" alt="image-20210221224612240"></p></li><li><p>保存之后点击域名设置-&gt;域名信息-&gt;健康诊断，看一下域名解析通不通过（我这边还是301，但是不知道为啥就是可以正常访问注册的域名了）</p><p><img src="/img/image-20210221224752104.png" alt="image-20210221224752104"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GithubPages </tag>
            
            <tag> Godaddy </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
