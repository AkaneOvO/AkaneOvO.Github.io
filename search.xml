<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅析Jupyterhub Authenticator的使用</title>
      <link href="2021/03/07/jupyterhub_2/"/>
      <url>2021/03/07/jupyterhub_2/</url>
      
        <content type="html"><![CDATA[<p>前面提到了Hub的一个重要作用：对登录的用户进行身份认证，那俺们来详细讲讲这个<code>Authenticator</code>是怎么用的</p><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">阮一峰：OAuth2.0的四种方式</a></p><p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">阮一峰：JSON Web Token 入门教程</a></p><p><a href="https://www.loginradius.com/blog/async/using-jwt-with-oauth2-when-and-why/">How to Use JWT with OAuth</a></p><h3 id="LoginHandler处理逻辑"><a href="#LoginHandler处理逻辑" class="headerlink" title="LoginHandler处理逻辑"></a>LoginHandler处理逻辑</h3><p>默认的<code>login_url</code>是<code>/hub/login</code>，当我们在浏览器窗口输入<code>localhost:8000</code>时，会由<code>RootHandler</code>进行处理，如果它发现找不到当前用户的话，就会跳转到<code>login_url</code>的位置，也就需要<code>LoginHandler</code>进行处理，也就是登录认证</p><img src="/img/image-20210308162027033.png" alt="image-20210308162027033" style="zoom:80%;" /><p>跳转到<code>/hub/login</code>之后，对应的是<code>LoginHandler</code>的<code>get</code>方法的处理逻辑，有两种处理方式：</p><ul><li><p>如果没有设置<code>authenticator.auto_login</code>，就会渲染出需要输入用户名和密码的页面</p><p>当输入了用户名和密码并确认之后，会调用<code>LoginHandler</code>的<code>POST</code>方法，将对应的<code>data</code>作为参数发送给<code>login_user</code>方法，而<code>login_user</code>方法再把这些<code>data</code>作为参数传给我们使用的<code>Authenticator</code>的<code>authenticate</code>方法</p><p>如果认证成功，则会返回用户的信息，否则返回为空，认证成功的用户会跳转到对应的页面去</p></li><li><p>如果设置了<code>authenticator.auto_login</code></p><ul><li>我们设置的<code>auto_login_url</code>和默认的<code>login_url</code>相等的话，会调用<code>login_user</code>方法，然后调用我们实现的<code>authenticator</code>的<code>authenticate</code>方法来实现对应的处理逻辑（用来认证的信息已经在<code>request</code>里面了）</li><li>如果不相等，则会跳转到我们设置的<code>auto_login_url</code>的位置进行处理（后面会讲到的OAuth2使用的就是这种方式，对应的<code>authenticator</code>的<code>login_url</code>已经在<code>jupyterhub_config.py</code>文件中设置了）</li></ul></li></ul><img src="/img/image-20210308163241400.png" alt="image-20210308163241400" style="zoom:80%;" /><h3 id="PAMAuthenticator"><a href="#PAMAuthenticator" class="headerlink" title="PAMAuthenticator"></a>PAMAuthenticator</h3><p>JupyterHub默认使用的<code>Authenticator</code>是<code>PAMAuthenticator</code>，可以在<code>auth.py</code>里面找到它</p><p><code>PAMAuthenticator</code>使用的是<code>pamela</code>模块来进行认证</p><img src="/img/image-20210308163837826.png" alt="image-20210308163837826" style="zoom:80%;" /><blockquote><p>PAM（Pluggable Authentication Modules ）是由Sun提出的一种认证机制。它通过提供一些动态链接库和一套统一的API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段</p></blockquote><p><code>Pamela</code>是PAM的一个python wrapper</p><h3 id="OAuth2和JWT"><a href="#OAuth2和JWT" class="headerlink" title="OAuth2和JWT"></a>OAuth2和JWT</h3><h4 id="什么是OAuth2"><a href="#什么是OAuth2" class="headerlink" title="什么是OAuth2"></a>什么是OAuth2</h4><p>如果当前我有一个应用A，它想要获得我的谷歌账号中的图片信息，但出于安全考虑，我又不能直接把我的谷歌账号密码给他，让他直接登录我的谷歌账号下载图片。于是我就要在这个应用和谷歌之间设置一个授权层，让应用A只能登录到授权层去获取开放的资料，对于不在授权层范围内的东西，它就接触不到</p><p>而OAuth就实现了在应用和服务提供商之间，设置了这样一个授权层。该应用登录到授权层使用的令牌和我登录谷歌使用的密码不同，且是有权限范围和有效期的</p><p><strong>重点</strong>：客户端（应用）必须得到用户的授权（authorization grant）之后才能获得令牌（access token），然后通过令牌去登录到授权层访问需要的东西</p><h4 id="OAuth2流程"><a href="#OAuth2流程" class="headerlink" title="OAuth2流程"></a>OAuth2流程</h4><p>OAuth2共有四种访问模式，这里只讲授权码（Authorization Code）模式（其他的感觉都是它的简化版）</p><p>OAuth2的运行流程一共有六个步骤：</p><ul><li>用户打开客户端，客户端要求用户予以授权（客户端跳转到登录/认证页面）</li><li>用户同意对客户端进行授权（用户在跳转的页面输入用户名密码等信息，点击确认，获得<code>AUTHORIZATION_CODE</code>（之类的））</li><li>客户端使用上一步获得的授权，向认证服务器申请令牌（access_token）</li><li>认证服务器对客户端进行认证后，确认无误，发放令牌</li><li>客户端使用令牌，向资源服务器申请获取资源</li><li>服务器确认令牌无误，同意开放资源</li></ul><p>好家伙，上面一通乱讲完全听不懂</p><p>那我们来看个栗子</p><p>前面提到，如果我在<code>jupyterhub_config.py</code>文件里面设置了自己的<code>login_url</code>，那么<code>LoginHandler</code>就会跳转到对应的处理逻辑</p><p>这里假设我们在<code>jupyterhub_config.py</code>文件中设置的<code>login_url</code>为<code>myoauth_login</code>，并在初始化的时候为我们的hub添加了一个关于处理<code>/myoauth_login</code>的<code>RequestHandler</code>的子类（我们叫他<code>MyOauthHandler</code>好了），那么输入<code>localhost:8000</code>的时候就会跳转到这个<code>MyOauthHandler</code>的<code>get</code>方法来进行处理</p><p>对着上面六个步骤依葫芦画瓢：</p><h5 id="step1-amp-2"><a href="#step1-amp-2" class="headerlink" title="step1&amp;2"></a>step1&amp;2</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyOauthHandler</span></span><br><span class="line"><span class="comment"># 第1&amp;2步，客户端让用户跳转到登录页面进行授权，用户同意授权</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">    redirect_url = self.authenticator.get_callback_url(self)</span><br><span class="line">    ...</span><br><span class="line">    self.authorize_redirect(</span><br><span class="line">    redirect_url = redirect_url,</span><br><span class="line">        client_id = client_id,</span><br><span class="line">        scope = self.authenticator.scope,</span><br><span class="line">        response_type = code</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>讲讲这些参数是干啥用的：</p><ul><li><code>redirect_url</code>：用户登录之后点击了确认，认证服务器总要把授权码返回吧，那我的认证服务器知道要返回到哪个url就要靠这个<code>redirect_url</code></li><li><code>client_id</code>：告诉认证服务器是谁在请求</li><li><code>scope</code>：要求授权的范围是啥</li><li><code>response_type</code>：要求返回的是啥，如果<code>response_type</code>为<code>code</code>，则要求返回授权码（四种访问模式要求的<code>response_type</code>是不一样的）</li><li>还可以加入一些额外的参数，比如<code>extra_params</code>之类的</li></ul><p>关于<code>scope</code>、<code>callback_url</code>等，都可以在<code>jupyterhub_config.py</code>文件中进行设置</p><h5 id="step3-amp-4"><a href="#step3-amp-4" class="headerlink" title="step3&amp;4"></a>step3&amp;4</h5><p>当用户授权完毕后，认证服务器会跳转到我们设置的<code>redirect_url</code>的位置，因此我们需要事先为它设置相应的<code>RerequestHandler</code>的子类来进行处理</p><p>假设我们设置的<code>redirec_url</code>为<code>myoauth_callback</code>，对应的<code>RequestHandler</code>子类为<code>MyCallbackHandler</code>，那么我们就可以在<code>get()</code>方法中拿到认证服务器返回给我们的<code>AUTHORIZATION_CODE</code></p><p>一个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyCallbackHandler</span></span><br><span class="line"><span class="comment"># 第3&amp;4步，客户端使用上一步获得的授权码，向认证服务器申请令牌，认证服务器认证无误后发放令牌</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_code</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.get_argument(<span class="string">&quot;code&quot;</span>,<span class="literal">False</span>):</span><br><span class="line">        <span class="keyword">raise</span> web.HTTPError(...)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_user</span>():</span></span><br><span class="line">params = <span class="built_in">dict</span>(</span><br><span class="line">    redirect_uri = self.get_callback_url(handler)</span><br><span class="line">        code = code,</span><br><span class="line">        grant_type = <span class="string">&#x27;authorization_code&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    // ...</span><br><span class="line">    token_resp_json = <span class="keyword">await</span> self._get_token(...,params)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    self.check_code()</span><br><span class="line">    // ...</span><br><span class="line">    self.login_user()</span><br></pre></td></tr></table></figure><p><img src="/img/image-20210308234648714.png" alt="image-20210308234648714"></p><p>从上面这张图里，可以看出服务器返回的数据中有我们要的<code>code</code>的信息，然后我们调用<code>login_user()</code>方法，拿着授权码去找认证服务器要令牌</p><p>再来讲讲里面的参数：</p><ul><li><code>client_id</code>：用来让认证服务器确认客户端的身份</li><li><code>client_secret</code>：用来加密</li><li><code>grant_type</code>：说明授权方式（这里写的<code>authorization_code</code>表示是授权码方式）</li><li><code>code</code>：上一步拿到的授权码</li><li><code>redirect_url</code>：拿到了令牌后认证服务器的回调地址</li></ul><p>好家伙，当<code>self._get_token()</code>执行完的之后，我们就可以在<code>token_resp_json</code>里面拿到我们要用的令牌了（<code>access_token</code>字段）</p><h5 id="step5-amp-6"><a href="#step5-amp-6" class="headerlink" title="step5&amp;6"></a>step5&amp;6</h5><p>我们可以在<code>login_user()</code>方法里面继续往下写拿到了令牌之后的操作，去找服务器要用户数据（这个时候已经有令牌了，nice）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_user</span>():</span></span><br><span class="line">params = <span class="built_in">dict</span>(</span><br><span class="line">    redirect_uri = self.get_callback_url(handler)</span><br><span class="line">        code = code,</span><br><span class="line">        grant_type = <span class="string">&#x27;authorization_code&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    // ...</span><br><span class="line">    token_resp_json = <span class="keyword">await</span> self._get_token(...,params)</span><br><span class="line">    user_data_resp_json = <span class="keyword">await</span> self._get_user_data(...,token_resp_json)</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><p>这里我们把上一步拿到的令牌作为参数传给了<code>_get_user_data()</code>方法，它就可以取出里面的令牌去找服务器要数据啦</p><p>（OAuth2流程大概就长这样）</p><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><blockquote><p>JWT，即JSON Web Token，是目前最流行的跨域认证解决方案，常用于无状态身份认证</p></blockquote><p>JWT的基本原理是，服务器不保存session数据（这样服务器就变成无状态的了），将所有的数据都保存在客户端，在服务器认证后生成一个JSON对象，用户之后每一次和服务器通信都会把这个JSON对象发送给服务器，服务器靠它来认证用户的身份</p><p>但是为了防止用户篡改数据，服务器生成这个JSON对象的时候，会加上签名（后面将JWT结构会讲到）</p><p>JWT主要由三部分组成：</p><ul><li><code>Header</code>：元数据，签名的算法、token类型等</li><li><code>Payload</code>：实际要传送的数据</li><li><code>Signature</code>：对前两部分的签名，需要一个secret，使用header中指定的签名算法产生签名</li></ul><p>之后客户端和服务器每次通信都带上这个JWT，把它放在Authorization字段里面</p><h5 id="Using-JWT-with-OAuth2"><a href="#Using-JWT-with-OAuth2" class="headerlink" title="Using JWT with OAuth2"></a>Using JWT with OAuth2</h5><p>因为OAuth2的协议中并没有指定令牌的格式，因此可以将JWT应用到OAuth2中</p><p>从OAuth2认证服务器返回回来的access_token可以是JWT的格式，且可以通过payload携带额外的信息</p>]]></content>
      
      
      <categories>
          
          <category> JupyterHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JupyterHub </tag>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git内部原理-笔记</title>
      <link href="2021/03/04/gitInternalPrinciple/"/>
      <url>2021/03/04/gitInternalPrinciple/</url>
      
        <content type="html"><![CDATA[<p>看了之后总觉得之前操作系统实验不是白写的╰(￣ω￣ｏ)</p><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html">阮一峰:Git原理入门</a></p><p><a href="https://segmentfault.com/a/1190000016320008">Git数据存储的原理浅析</a></p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1">Git内部原理－Git对象</a></p><p><code>.git</code>目录是维护git信息的目录</p><h2 id="git文件结构"><a href="#git文件结构" class="headerlink" title="git文件结构"></a>git文件结构</h2><p><code>.git</code>文件中的内容</p><p><img src="/img/clip_image002.png" alt="img"></p><ul><li><p>HEAD</p><p>当前提交的指针的位置</p><p><img src="/img/clip_image004.png" alt="img"></p></li><li><p>refs/head</p><p>保存了本地全部分支最后一次提交的id</p><p>由于每一次commit的实际上是commit一个文件，而这个id就是commit文件的hash值，这种方式贯穿了git的全部文件的命名</p><p><img src="/img/clip_image005.png" alt="img"></p></li><li><p>log</p><p>每一次提交的记录</p><p><img src="/img/clip_image007.png" alt="img"></p></li><li><p>objects</p><p>存放git本地仓库对象</p></li></ul><h2 id="Git底层数据对象"><a href="#Git底层数据对象" class="headerlink" title="Git底层数据对象"></a>Git底层数据对象</h2><p><img src="/img/clip_image009.png" alt="img"></p><ul><li><p>tag对象</p></li><li><p>blob对象</p><p>用于存储文件内容（不会保存文件名）</p><p>因为<code>git add .</code>命令实际上执行的是</p><ul><li>保存对象（<code>git hash-object</code>）</li><li>更新暂存区（<code>git update-index</code>，在暂存区记录一个发生变动的文件）</li></ul><p>其中<code>git hash-object</code>做的就是就是把文件的内容压缩为二进制文件，称为一个git对象（文件的话就是blob对象），保存在<code>.git/objects</code>目录中</p><p>使用<code>git hash-obejct</code>命令还会计算当前内容的<code>SHA1</code>哈希值（长度为40的字符串），作为该对象的文件名，其中前两个字母为object文件夹中的文件夹名，后面的字母为该文件夹下的文件名，如果用<code>cat</code>查看的话会发现里面是一些压缩后的二进制内容</p><p><img src="/img/clip_image011.png" alt="img"></p></li><li><p>tree对象</p><p>用于存储当前目录结构，能够保存文件名，将多个文件组织到一起</p><p><code>git write-tree</code>命令能够将当前的目录结构生成一个git对象（tree对象），也保存在<code>.git/object</code>目录中</p></li><li><p>commit对象</p><p><code>commit</code>的时候有提交说明，包括所在的tree，parent（父提交）是谁，作者等信息</p><p><code>git commit-tree</code>命令将元数据（blob）和目录树（tree）一起生成一个git对象（commit对象），也保存在<code>git/object</code>目录中</p><p>这样通过上面那张图，就可以大致看出git本地存储的文件结构了</p></li></ul><p>在每一次提交的时候，objects、logs以及refs文件夹都会发生变化：</p><ul><li>objects文件夹中新增对应的tree、blob以及commit对象（通过SHA-1对内容和头信息生成Hash值）</li><li>logs文件夹中对应分支的文件新增一次提交记录</li><li>更改refs文件夹中对应分支最新一次提交的id（commit对象的值）</li></ul><h2 id="剖析Git对象"><a href="#剖析Git对象" class="headerlink" title="剖析Git对象"></a>剖析Git对象</h2><p>由于<code>.git/objects</code>目录中的文件都是压缩过的，可以使用<code>cat-file</code>命令从git中取回数据（剖析git对象），<code>-p</code>选项可以使该命令自动判断内容的类型，并展示大致内容</p><p>如果删掉了本地的副本，而<code>.git/objects</code>中还保存着压缩后的内容，在知道对应的SHA-1的情况下，可以取回对应的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span><br></pre></td></tr></table></figure><h2 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h2><p>由于Git最初向磁盘中存储对象所使用的格式为loose格式，它会时不时将多个这些对象打包成一个packfile的二进制文件，用来节省空间和提升效率（垃圾回收，手动方式：<code>git gc --auto</code>，可以通过<code>gc.auto</code>和<code>gc.autopacklimit</code>来设置超过多少个松散对象和包文件才让git启动一次gc命令）</p><p>可以使用<code>git gc</code>命令对Git对象进行打包；向远程服务器进行推送时，git也会打包</p><p>打包之后，你的<code>objects</code>目录可能变成这个样子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">.git/objects/info/packs</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</span><br></pre></td></tr></table></figure><p><code>pack</code>是一个包文件，而<code>idx</code>是对应的索引文件</p><p>索引文件中包含了包文件的偏移信息，可以通过索引文件快速定位任意一个指定对象</p><p>git打包对象时，会查找命名及大小相近的文件，且保存不同文件版本之间的差异</p><p>如果执行了<code>git gc</code>命令，该命令还会将<code>refs</code>文件夹中的文件进行打包，将其移动到名为<code>.git/packed-refs</code>的文件中，因此，如果你在<code>refs</code>目录中找不到一个引用，那么它可能在<code>packed-refs</code>文件中 </p><p>那么那么那么，学习了上面的知识，如果不采用传送整个<code>.git</code>文件夹的方式，每次要把本地<code>commit</code>的文件传送到远端，我们需要发送哪些文件嘞(σ｀д′)σ</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>明日方舟 双人CE-5系列</title>
      <link href="2021/03/02/aknights_1/"/>
      <url>2021/03/02/aknights_1/</url>
      
        <content type="html"><![CDATA[<p>摸鱼使我快乐.jpg</p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=204442921&bvid=BV12h411k7N9&cid=305192999&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><p>好家伙我又摸鱼了</p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=844544971&bvid=BV1x54y1a7kC&cid=307324801&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 摸鱼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 明日方舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件权限</title>
      <link href="2021/02/28/LinuxFilePermission/"/>
      <url>2021/02/28/LinuxFilePermission/</url>
      
        <content type="html"><![CDATA[<p><a href="http://cn.linux.vbird.org/">鸟哥的Linux私房菜</a>看着有点意思</p><p>因为之前配环境装东西的时候因为文件的权限问题搞了好久，看了鸟哥的书之后整理一下</p><h2 id="1-用户和用户组"><a href="#1-用户和用户组" class="headerlink" title="1.用户和用户组"></a>1.用户和用户组</h2><p>因为Linux是个多人多任务的系统，所以对文件权限的管理就非常的重要</p><p>用户和用户组可以解决：</p><ul><li>只属于自己的文件不想给别人看</li><li>同一组的文件只能在组内共享，别人看不了</li></ul><p>的问题</p><p>这里有三个概念：</p><ul><li>用户（User）</li><li>用户组（Group）</li><li>其他人（Other）</li></ul><p>Linux中任何一个文件都有这三种身份的权限</p><p>举一个栗子，用户相当于akane，用户组相当于akane家，akane的兄弟姐妹也是不同的用户，而akane和ta的兄弟姐妹就组成了一个用户组。akane的小金库不想和兄弟姐妹共享，那么这个小金库就只对akane开放，对于akane所在的用户组中的其他用户都是不开放的；而不属于akane所在组的用户就属于others，akane的小金库对他们也是不开放的；而akane家的冰箱对于akane和ta的兄弟姐妹都是开放的，大家可以自己拿自己想吃的东西，但是对于others是不开放的（比如说他们不希望别人随便来他们家冰箱找吃的）</p><p>但是全能的神可以不管akane或者ta的兄弟姐妹想不想把东西给他看，对世间万物（?）都可以随便拿随便看，在Linux中这个全能的神就是root</p><p>Linux的文件权限差不多就类似于上面栗子的玩意</p><h2 id="2-Linux文件属性"><a href="#2-Linux文件属性" class="headerlink" title="2.Linux文件属性"></a>2.Linux文件属性</h2><p>在terminal使用命令<code>su -</code>切换到<code>root</code>身份后，输入命令<code>ls -al</code>，可以看到类似于下面的Linux文件的详细信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls -al</span><br><span class="line">total 156</span><br><span class="line">drwxr-x---   4    root   root     4096   Sep  8 14:06 .</span><br><span class="line">drwxr-xr-x  23    root   root     4096   Sep  8 14:21 ..</span><br><span class="line">-rw-------   1    root   root     1474   Sep  4 18:27 anaconda-ks.cfg</span><br><span class="line">-rw-------   1    root   root      199   Sep  8 17:14 .bash<span class="emphasis">_history</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root       24   Jan  6  2007 .bash_</span>logout</span><br><span class="line">-rw-r--r--   1    root   root      191   Jan  6  2007 .bash<span class="emphasis">_profile</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root      176   Jan  6  2007 .bashrc</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root      100   Jan  6  2007 .cshrc</span></span><br><span class="line"><span class="emphasis">drwx------   3    root   root     4096   Sep  5 10:37 .gconf      </span></span><br><span class="line"><span class="emphasis">drwx------   2    root   root     4096   Sep  5 14:09 .gconfd</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root    42304   Sep  4 18:26 install.log &lt;=范例说明处</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root     5661   Sep  4 18:25 install.log.syslog</span></span><br><span class="line"><span class="emphasis">[<span class="string">    1   </span>][<span class="symbol">  2 </span>][<span class="string">   3  </span>][<span class="symbol">  4 </span>][<span class="string">    5   </span>][<span class="symbol">     6     </span>][<span class="string">       7          </span>]</span></span><br><span class="line"><span class="emphasis">[<span class="string">  权限  </span>][<span class="symbol">link</span>][<span class="string">user</span>][<span class="symbol">group</span>][<span class="string">文件容量</span>][<span class="symbol">  修改日期 </span>][<span class="string">      文件名        </span>]</span></span><br></pre></td></tr></table></figure><p>我们拿出第一个范例来看</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>对于范例处，也就是<code>-rw-r--r--</code>的内容</p><p>总共有十个字符，一般这样划分：<code>-/rw-/r--/r--</code></p><p>第一个字母表示的是该文件的类型，是文件还是文件夹还是链接文件等，这里介绍主要的几种</p><ul><li><code>d</code>：文件夹</li><li><code>-</code>：普通文件</li><li><code>l</code>：链接文件，也就是windows里面的快捷方式</li></ul><p>还有其他的文件类型，可以去看看鸟哥写的（懒狗发言）</p><p>之后的三个字符一组，分别表示的是：</p><ul><li>文件拥有者对文件的读、写、执行权限</li><li>文件所属用户组对文件的读、写、执行权限</li><li>其他人对该文件的读、写、执行权限</li></ul><p>在这个例子里：</p><ul><li>文件拥有者的读、写、执行权限为：<code>rw-</code></li><li>文件所属用户组对文件的读、写、执行权限为：<code>r--</code></li><li>其他人对该文件的读、写、执行权限为：<code>r--</code></li></ul><p>这三个字符是有固定位置的，分别为<code>rwx</code>，其中<code>r</code>表示可读，<code>w</code>表示可写，<code>x</code>表示可执行（对于文件和文件夹这三个字符的表示含义又有一些不同，之后会讲到）</p><p>如果没有对应的权限的话，该位置就会变成<code>-</code></p><p>例如，如果该用户对此文件有读和执行的权限，没有写的权限，则表示为<code>r-x</code></p><p>对于上面这个栗子，可以看出：</p><ul><li>文件拥有者对该文件可读可写（<code>rw-</code>）</li><li>文件所属用户组对该文件只可读（<code>r--</code>）</li><li>其他用户对该文件只可读（<code>r--</code>）</li></ul><p>举一个别的栗子，假设一个文件的权限部分写的是<code>drwxr-xr--</code>，我们可以做的事有：</p><ul><li>划分成<code>d/rwx/r-x/r--</code></li><li>第一个字符为<code>d</code>，说明这个文件是个文件夹</li><li>第一组三个字符为<code>rwx</code>，说明该文件所属的用户对该文件可读可写可执行</li><li>第二组三个字符为<code>r-x</code>，说明该文件所属用户组对该文件可读可执行</li><li>第三组三个字符为<code>r--</code>，说明其他用户对该文件只可读</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之后几栏分别表示什么呢</p><ul><li>十个字符后面的数字，也就是第二栏，表示的是链接数，说明有多少个文件名链接到这个结点</li><li>第三栏：该文件的拥有者账号</li><li>第四栏：该文件所属的用户组</li><li>第五栏：文件大小</li><li>第六栏：文件的创建日期或最近修改日期</li><li>第七栏：文件名</li></ul><h2 id="3-修改文件属性和权限"><a href="#3-修改文件属性和权限" class="headerlink" title="3.修改文件属性和权限"></a>3.修改文件属性和权限</h2><p><strong>警告</strong>：<code>chgrp</code>、<code>chown</code>和<code>chmod</code>只能在<code>root</code>下执行</p><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>即：change group，修改文件所属的用户组</p><p>一般格式：<code>chgrp [-R] groupname dirname/filename</code></p><p>其中<code>[-R]</code>表示进行递归的修改，用于修改目录所属用户组的时候，使其子目录和该目录下的文件也变成这个用户组的</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>即：change owner，修改文件所属用户</p><p>一般格式：<code>chown [-R] username dirname/filename</code></p><p>如果想同时修改文件所属的用户和用户组，也可以使用<code>chown</code>，格式为<code>chown [-R] username:groupname dirname/filename</code></p><p>也可以用<code>chown</code>来修改文件所属的用户组：<code>chown [-R] :groupname dirname/filename</code></p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>这个命令可以用来修改文件对于拥有者、所属用户组以及其他用户的读写执行权限</p><p>格式为：<code>chmod [-R] xyz dirname/filename</code></p><p>那么，<code>xyz</code>是什么呢</p><p>还记得之前三个三个分组的<code>rwx</code>吗，<code>r</code>表示4，<code>w</code>表示2，<code>x</code>表示1，对应用户/用户组/其他人拥有的权限对应的数字加起来得到的值，就是<code>chmod</code>命令中写的数字<code>xyz</code>了</p><p>举一个栗子，如果我们希望把一个文件的读写权限改成<code>rwx/r-x/r--</code>，那么对应的数字就是<code>754</code>，对应的命令就是<code>chmod 754 filename</code></p><p>如果写的命令是<code>chmod 777 filename</code>，就说明让这个文件对所有的用户可读可写可执行</p><h4 id="符号方式修改"><a href="#符号方式修改" class="headerlink" title="符号方式修改"></a>符号方式修改</h4><p>除了刚刚那种直接写数字的方法，还可以用符号来修改文件的权限</p><p>我们用<code>u</code>表示<code>user</code>，<code>g</code>表示<code>group</code>，<code>o</code>表示<code>other</code>，<code>a</code>表示全部</p><p><code>+</code>表示增加权限，<code>-</code>表示取消权限，<code>=</code>表示设置</p><p>希望看了下面的栗子能看出来它是怎么用的（狗头）</p><ul><li><p><code>chmod u=rwx,g=rw- filename</code>：文件拥有者权限设置为可读可写可执行，文件所属用户组权限设置为可读可写</p></li><li><p><code>chmod o-x filename</code>：去除其他用户对文件的可执行权限</p></li><li><p><code>chmod a+w filename</code>：为所有的用户加上对文件的可写权限</p></li></ul><h2 id="4-文件与目录的权限意义"><a href="#4-文件与目录的权限意义" class="headerlink" title="4.文件与目录的权限意义"></a>4.文件与目录的权限意义</h2><p>对文件：</p><ul><li><code>r</code>：可以读取文件内容</li><li><code>w</code>：可以编辑、修改、删除文件内容，但是<strong>不可以删除文件</strong></li><li><code>x</code>：该文件可以被系统执行</li></ul><p>对文件夹：</p><ul><li><code>r</code>：可以查询该目录下的文件名数据（但是如果没有<code>x</code>的话，就仅限于查看文件名）</li><li><code>w</code>：可以新建、删除、移动、重命名文件/文件夹</li><li><code>x</code>：<strong>可以进入这个文件夹作为你的工作目录</strong>，不然就只能在外面看看（如果这个文件夹对你来说没有<code>x</code>的话，你是<code>cd</code>不进去的）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Jupyterhub架构</title>
      <link href="2021/02/26/jupyterhub_1/"/>
      <url>2021/02/26/jupyterhub_1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于tornado"><a href="#关于tornado" class="headerlink" title="关于tornado"></a>关于tornado</h2><p>由于jupyterhub是非常典型的tornado应用结构，因此需要一些关于tornado的知识 <a href="https://tornado-zh.readthedocs.io/zh/latest/guide/structure.html">tornado官方文档链接</a></p><blockquote><p>A Tornado web application generally consists of one or more RequestHandler subclasses, an Application object with routes incoming requests to handlers, and a main() function to start the server</p></blockquote><p>一个tornado应用主要包括三部分：</p><ul><li>一个<code>Application</code>对象：用于全局配置，将请求的路由映射到对应的handler</li><li>多个<code>RequestHandler</code>子类：用于执行对应url的处理逻辑</li><li>一个启动服务的<code>main()</code>函数</li></ul><p><img src="/img/tornado.jpg" alt="tornado"></p><h3 id="Application对象"><a href="#Application对象" class="headerlink" title="Application对象"></a>Application对象</h3><p><code>Application</code>对象负责全局配置，将请求的路由映射到对应的handler，因此需要传递给<code>Application</code>一个路由表（<code>URLSpec</code> object list）用于进行路由的配置</p><p><a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings">官方Application configuration文档</a></p><h4 id="URLSpec"><a href="#URLSpec" class="headerlink" title="URLSpec"></a>URLSpec</h4><p>一个<code>URLSpec</code>的栗子：<code>url(r&quot;/story/([0-9]+)&quot;, StoryHandler, dict(db=db), name=&quot;story&quot;)</code></p><p>主要包含四个部分：**(matcher,** <strong>target,</strong> <strong>[target_kwargs],</strong> <strong>[name])</strong></p><ul><li>正则表达式（必写）：用于与url进行匹配，采用first matching rule</li><li>处理类（必写）：一个<code>RequestHandler</code>的子类，实现处理逻辑</li><li>dict（可选）：作为初始参数传给<code>RequestHandler.initialize()</code></li><li>name（可选）：允许其被<code>RequestHandler.reverse_url</code>使用</li></ul><p>对<code>Application</code>进行配置的时候不仅可以配置路由表，还可以配置其他的信息 </p><p>要添加额外的handlers，可以使用<code>application.add_handlers()</code>，添加额外的路由信息</p><h4 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h4><p>Settings主要用于自定义tornado的很多方面，这里只展示了部分，关于全部<code>settings</code>的内容请看<a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings">官方文档</a></p><ul><li>General settings</li><li>Authentication and security settings<ul><li><code>cookie_secret</code>：用于对cookies进行签名 <a href="https://blog.csdn.net/adley_app/article/details/80734247">cookie防篡改机制</a></li><li><code>login_url</code>：如果用户没有登录，<code>authenticated</code>装饰器将会重定向到这个url。可以通过重写<code>RequestHandler.get_login_url</code>进行自定义</li></ul></li><li>Template settings<ul><li><code>template_path</code>：包含template文件的路径</li></ul></li><li>Static file settings<ul><li><code>static_path</code>：静态文件所在文件夹</li><li><code>static_url_prefix</code>：静态文件的url前缀</li></ul></li></ul><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>一个将URLSpec list传入<code>Application</code>进行配置的栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app = Application([</span><br><span class="line">    url(<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    url(<span class="string">r&quot;/story/([0-9]+)&quot;</span>, StoryHandler, <span class="built_in">dict</span>(db=db), name=<span class="string">&quot;story&quot;</span>)</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>我们还可以加入自己的settings</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">settings = <span class="built_in">dict</span>(...)</span><br><span class="line">app = Application([</span><br><span class="line">    url(<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    url(<span class="string">r&quot;/story/([0-9]+)&quot;</span>, StoryHandler, <span class="built_in">dict</span>(db=db), name=<span class="string">&quot;story&quot;</span>)</span><br><span class="line">    ],settings)</span><br></pre></td></tr></table></figure><h3 id="RequestHandler子类"><a href="#RequestHandler子类" class="headerlink" title="RequestHandler子类"></a>RequestHandler子类</h3><blockquote><p>The main entry point for a handler subclass is a method named after the HTTP method being handled: <code>get()</code>, <code>post()</code>, etc. Each handler may define one or more of these methods to handle different HTTP actions.</p></blockquote><p>RequestHandler的子类主要用来处理http请求，进行对应的操作，主要需要实现的有<code>get</code>和<code>post</code>方法</p><h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><p><code>render</code>方法可以使用<code>template</code>用对应的参数进行渲染，<code>write</code>方法则不使用<code>template</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFormHandler</span>(<span class="params">tornado.web.RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.render(<span class="string">&#x27;index.html&#x27;</span>, message=file_url)</span><br></pre></td></tr></table></figure><h4 id="处理输入请求"><a href="#处理输入请求" class="headerlink" title="处理输入请求"></a>处理输入请求</h4><p><code>self.request</code>可以访问到当前的请求对象，如果是通过HTML表单格式请求的数据会被解析，且能够通过<code>get_query_argument</code>和<code>get_body_argument</code>进行访问</p><p><a href="https://tornado-zh.readthedocs.io/zh/latest/httputil.html#tornado.httputil.HTTPServerRequest">HTTPServerRequest完整属性列表</a></p><h4 id="RequestHandler的调用序列"><a href="#RequestHandler的调用序列" class="headerlink" title="RequestHandler的调用序列"></a>RequestHandler的调用序列</h4><ul><li>创建一个新的<code>RequestHandler</code></li><li>调用<code>initialize()</code>方法（还记得前面传递的参数吗）</li><li>调用<code>prepare()</code>方法</li><li>调用某个HTTP method：GET/POST/PUT</li><li>结束时调用<code>on_finish()</code>方法</li></ul><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>大概了解了<code>Application</code>以及<code>RequestHandler</code>子类之后，就可以写出一个最简单的hello world了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">tornado.web.RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span>():</span></span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([</span><br><span class="line">        (<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><h3 id="认证和安全"><a href="#认证和安全" class="headerlink" title="认证和安全"></a>认证和安全</h3><p>刚刚提到，在给<code>application</code>传递参数时，有一个选项为<code>cookie_secret</code>，该密钥是用来对cookies进行签名防止伪造的，这里提一下tornado的认证与安全，jupyterhub也会使用到</p><p>进行签名后的cookies会包含了编码后得cookie值、时间戳以及一个HMAC signature，<code>get_secure_cookie</code>方法会对其值进行验证，如果不通过则会返回<code>None</code>；若需要使用<code>cookie_secret</code>对cookie进行签名，则可以使用<code>set_secure_cookie</code>方式</p><p>在<code>RequestHandler</code>的子类，即我们自己编写的<code>Handler</code>中，有时我们需要确认实现用户认证，就需要复写请求处理函数<code>get_current_user</code>来对当前用户进行判断，比如可以基于cookie的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseHandler</span>(<span class="params">tornado.web.RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current_user</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.get_secure_cookie(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">BaseHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.current_user:</span><br><span class="line">            self.redirect(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        name = tornado.escape.xhtml_escape(self.current_user)</span><br><span class="line">        self.write(<span class="string">&quot;Hello, &quot;</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span>(<span class="params">BaseHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;Name: &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;&lt;input type=&quot;submit&quot; value=&quot;Sign in&quot;&gt;&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.set_secure_cookie(<span class="string">&quot;user&quot;</span>, self.get_argument(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">        self.redirect(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    (<span class="string">r&quot;/login&quot;</span>, LoginHandler),</span><br><span class="line">], cookie_secret=<span class="string">&quot;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Jupyterhub基本架构"><a href="#Jupyterhub基本架构" class="headerlink" title="Jupyterhub基本架构"></a>Jupyterhub基本架构</h2><p>对tornado应用的结构有了初步的了解后，我们可以开始对Jupyterhub的架构一探究竟了</p><p>Jupyterhub的有几个主要的组成部分</p><ul><li>hub（tornado application）</li><li>proxy：面向用户的部分，使用动态代理来调整HTTP对hub或单用户的notebook服务发送的请求</li><li>notebook server</li></ul><h3 id="Hub"><a href="#Hub" class="headerlink" title="Hub"></a>Hub</h3><blockquote><p><strong>Hub</strong> (Python/Tornado): manages user accounts, authentication, and coordinates Single User Notebook Servers using a Spawner.</p></blockquote><p>hub的主要功能：</p><ul><li>对登录用户进行认证（Authenticator）</li><li>保存用户、service等数据（Database）</li><li>为用户分配单用户notebook server（Spawner）</li></ul><h4 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h4><blockquote><p>The <strong>Authenticator</strong> is the mechanism for authorizing users to use the Hub and single user notebook servers.</p></blockquote><p>当用户进行登录时，会调用配置的<code>Authenticator</code>的<code>authenticate</code>方法对用户进行认证（例如默认使用的是<code>PAMAuthenticator</code>，其<code>authenticate</code>方法中会获取用户输入的用户名和密码进行认证，也可使用别的<code>authenticator</code>进行认证）</p><p>如果需要使用自己写的<code>authenticator</code>，写好之后，可以在<code>jupyterhub_config.py</code>文件中进行设置：</p><p><code>c.JupyterHub.authenticator_class = &#39;yourpackage:YourAuthenticator&#39;</code></p><p>要查看关于<code>Authenticator</code>的源码，可以查看一下<code>jupyterhub/jupyterhub/auth.py</code>中的内容</p><h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><blockquote><p>JupyterHub uses a database to store information about users, services, and other data needed for operating the Hub.</p></blockquote><p>话不多说，直接谷歌翻译</p><h4 id="Spawner"><a href="#Spawner" class="headerlink" title="Spawner"></a>Spawner</h4><blockquote><p>A <strong>Spawner</strong> starts each single-user notebook server</p></blockquote><p>当用户登录后，如果对应的notebook server没有启动，可以通过<code>/spawn</code>页面中的表单提交选项，利用spawner去启动notebook server（<code>Spawner.start</code>）</p><p>spawn，谷歌翻译的意思是<em>产卵</em>，可能这样会好理解一点</p><p>通过spawner启动了对应的notebook server后，会得到该server的ip以及port，将会被注册到proxy的路由表中，这样当用户下一次要使用该server的时候，proxy就会根据这个ip以及port，将该用户直接跳转到这个notebook server对应的地址，对应jupyterhub中的url格式为<code>/url/:username/:servername</code>（<a href="https://jupyterhub.readthedocs.io/en/stable/reference/urls.html#user-username-servername">jupyterhub的URL模式</a>）</p><p>当spawner启动之后，会通过<code>Spawner.poll</code>来确认spawner是不是还或者，如果返回的是<code>None</code>，就说明它依然健在，否则可能出事了</p><p>如果要停下spawner的话，可以使用<code>Spawner.stop</code></p><p>更多有关的代码可以查看<code>jupyterhub/jupyterhub/spawner.py</code>中的内容</p><p>和<code>Authenticator</code>同理，如果想要使用自己写的<code>Spawner</code>，可以通过修改配置文件<code>jupyterhub_config.py</code>来实现：</p><p>``c.JupyterHub.spawner_class = ‘yourpackage:YourSpawner’`</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><blockquote><p>the public facing part of JupyterHub that uses a dynamic proxy to route HTTP requests to the Hub and Single User Notebook Servers. configurable http proxy(node-http-proxy) is the default proxy</p></blockquote><p>还记得前面说到的启动server后会返回ip以及port并将其注册到proxy的路由表中吗，proxy是hub的与用户进行交互的部分，能够根据路由表中的信息，使用动态代理来调整HTTP对hub或单用户的notebook服务发送的请求</p><p>默认的proxy使用的是<a href="https://github.com/jupyterhub/configurable-http-proxy">configurable http proxy</a>（不知道是不是网络问题文档一直打不开我裂开来）</p><h3 id="Notebook-server"><a href="#Notebook-server" class="headerlink" title="Notebook server"></a>Notebook server</h3><blockquote><p>a dedicated, single-user, Jupyter Notebook server is started for each user on the system when the user logs in. The object that starts the single-user notebook servers is called a <strong>Spawner</strong>.</p></blockquote><p>当用户登录了之后，就会启动对应的单用户jupyterhub notebook server，对应的功能描述看看<a href="https://jupyter.org/">文档</a>吧</p><h3 id="子系统的交互"><a href="#子系统的交互" class="headerlink" title="子系统的交互"></a>子系统的交互</h3><img src="https://img-blog.csdnimg.cn/20200708202115603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTE1MzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /><p>知道了上面三个Jupyterhub的基本组成部分（三大子系统），可以了解一下它们之间是怎么交互的啦</p><p>基本的流程大致长这个样子（建议结合上面官方的架构图进行食用）：</p><ul><li><p>hub产生proxy（可以参见源码<code>jupyterhub/jupyterhub/app.py</code>中<code>init_proxy</code>的部分），proxy默认将请求发送给hub</p></li><li><p>由于hub本质上是一个tornado application，那么从proxy中拿到的request全部都要由hub中注册的<code>requestHandler</code>的子类进行处理，例如：</p><ul><li>进行用户登录，并对用户的身份进行认证（<strong>Authenticator</strong>），用户的信息会被保存在<strong>database</strong>中</li><li>启动<strong>spawner</strong>生成<strong>notebook server</strong>，并将其注册到proxy的路由表中，等下一次要用的时候可以直接跳转到对应的server（**/user/[name]/**）</li><li>notebook server也可以通过hub中的authenticator等对用户身份进行认证等（**/api/auth**）</li></ul><p>…之类的操作</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>某些关于security settings的内容</p><h4 id="SSL-encryption"><a href="#SSL-encryption" class="headerlink" title="SSL encryption"></a>SSL encryption</h4><blockquote><p>You should not run JupyterHub without SSL encryption on a public network.</p></blockquote><p>SSL（Secure Sockets Layer）用于保障在网络上数据传输的安全，利用数据加密（Encryption）来确保数据在网络上传输过程中不会被窃取或监听</p><p>关于SSL协议的运行机制请看<a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">这篇</a></p><p>由于数据传输过程之前需要握手，网站需要向浏览器发送SSL证书，用于支持HTTPS网站的身份证明，其中包含了网站域名、证书有效期以及用于加密传输密码的公钥的信息</p><p>Jupyterhub需要使用SSL进行传输，因此需要配置SSL证书的信息，在<code>jupyterhub_config.py</code>文件中可以配置<code>ssl_key</code>以及<code>ssl_cert</code>的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.JupyterHub.ssl_key = <span class="string">&#x27;/path/to/my.key&#x27;</span></span><br><span class="line">c.JupyterHub.ssl_cert = <span class="string">&#x27;/path/to/my.cert&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="cookie-secret"><a href="#cookie-secret" class="headerlink" title="cookie secret"></a>cookie secret</h4><p><a href="https://blog.csdn.net/adley_app/article/details/80734247">关于cookie防篡改机制</a></p><blockquote><p>The cookie secret is an encryption key, used to encrypt the browser cookies which are used for authentication</p></blockquote><p>可以看出，cookie secret主要是用于对用户的cookie进行加密，同时防止用户对cookie进行篡改从而伪造成别人（还记得前面讲到的<code>Application</code>中<code>setting</code>参数中可以传入的<code>cookie_secret</code>吗，jupyterhub中也可以传入<code>cookie_secret</code>，同样也用于在<code>set_secure_cookie</code>以及<code>get_secure_cookie</code>中对用户进行认证或添加cookie）</p><p>在jupyterhub中，有三种方式可以生成和配置<code>cookie secret</code>，这里介绍其中的一种，更多的可以查看官方<a href="https://jupyterhub.readthedocs.io/en/stable/getting-started/security-basics.html?highlight=ssl#cookie-secret">介绍</a></p><p>同样还是配置<code>jupyterhub_config.py</code>文件，<code>c.JupyterHub.cookie_secret = bytes.fromhex(&#39;64 CHAR HEX STRING&#39;)</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/img/image-20210227222005582.png" alt="image-20210227222005582"></p><p>自己把之前那一张官方的架构图扩大了，希望有一点帮助吧</p><p>之后会继续写关于jupyterhub启动流程的东西，还是会扯到上面讲的很多内容</p><p>啊（懒狗叹气.jpg）</p>]]></content>
      
      
      <categories>
          
          <category> JupyterHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JupyterHub </tag>
            
            <tag> tornado </tag>
            
            <tag> cookie secret </tag>
            
            <tag> ssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo安装+butterfly主题配置</title>
      <link href="2021/02/22/HexoConfig/"/>
      <url>2021/02/22/HexoConfig/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=2d5c8b14-1a70-4516-a004-1962b3a68783&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">hexo史上最全搭建教程</a></li><li><a href="https://blog.csdn.net/qq_31880107/article/details/86688467">windows下Hexo博客搭建过程</a></li><li><a href="https://hexo.io/docs/">hexo官方文档</a></li><li><a href="https://valine.js.org/">Valine官方文档</a></li><li><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo博客搭建之在文章中插入图片</a></li></ul><h2 id="1-Hexo安装"><a href="#1-Hexo安装" class="headerlink" title="1.Hexo安装"></a>1.Hexo安装</h2><p>需要事先安装好：</p><ul><li><p>nodejs，可以使用<code>node -v</code>查看是否已经安装</p></li><li><p>git，可以使用<code>git --version</code>查看是否已经安装</p><p>一般下载完之后还需要将其配置到系统路径中，参考<a href="https://blog.csdn.net/weixin_43803924/article/details/104606989">这一篇</a></p></li></ul><p>确保都安装好后：</p><ul><li><p>新建一个空文件夹，<code>cd</code>进去</p></li><li><p>可以右键打开<code>powershell</code>，也可以使用<code>Git Bash</code>，按顺序执行以下命令</p><ul><li><p><code>npm install -g hexo</code></p></li><li><p><code>hexo init 你的文件夹名</code></p><p>初始化成功后会显示<code>Start blogging with Hexo!</code>，同时空文件夹下会多出一个你刚刚命名的文件夹</p><p><img src="/img/image-20210222173111226.png" alt="image-20210222173111226"></p></li></ul><center>输入的是hexo init akaneovoBlog</center></li><li><p><code>cd</code>进入到新创建的文件夹中，按顺序执行以下命令</p><ul><li><code>npm install</code></li><li><code>hexo g</code>或<code>hexo generate</code></li><li><code>hexo server</code></li></ul></li><li><p>此时会显示<code>Hexo is running at http://localhost:4000/</code>，可以打开浏览器查看，若展示出默认的博客，则安装成功</p></li></ul><h2 id="2-将本地博客托管到Github上"><a href="#2-将本地博客托管到Github上" class="headerlink" title="2.将本地博客托管到Github上"></a>2.将本地博客托管到Github上</h2><p>需要更改配置文件<code>_config.yml</code>，以上面的文件夹为例，其地址为：</p><p><img src="/img/image-20210222173540149.png" alt="image-20210222173540149"></p><p>其中的<code>myBlog</code>即一开始创建的空文件夹，<code>akaneovoBlog</code>为<code>hexo init</code>时创建的文件夹，</p><p><strong>不要用txt直接打开它，最好用vscode之类的文本编辑器</strong></p><p>修改<code>_config.yml</code>文件中的<code>deploy</code>，改成图示形式：</p><p><img src="/img/image-20210222173755509.png" alt="image-20210222173755509"></p><p><strong>冒号后面记得带一个空格</strong></p><p>其中<code>repository</code>为自己的github仓库地址，也可以写成http的，但是不知道为啥我用了半天之后突然间<code>hexo d</code>就报错了，改成上面这个格式的就好了</p><p>保存之后安装<code>hexo-deployer-git</code>插件：<code>npm install hexo-deployer-git --save</code></p><p>之后每次修改本地博客并上传到github，都要执行如下代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generator # 或简写为hexo g</span><br><span class="line">hexo deploy # 或简写为hexo d</span><br></pre></td></tr></table></figure><p>如果只是在本地更改了文件在本地进行测试：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>托管到github上面之后，可以通过<code>xxx.github.io</code>查看自己的个人博客，或者通过自己和Github Pages绑定的域名进行查看</p><h2 id="3-配置butterfly主题"><a href="#3-配置butterfly主题" class="headerlink" title="3.配置butterfly主题"></a>3.配置butterfly主题</h2><p>u1s1，butterfly比之前看到的anatole功能真的多了好多，文档也多了超级多</p><p>看<a href="https://butterfly.js.org/">官方文档</a>来配置就够啦</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Pages与个人域名绑定</title>
      <link href="2021/02/22/BlogConfig/"/>
      <url>2021/02/22/BlogConfig/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="https://cyclechen.me/2019/03/13/2019-03-13-setup-github-page-personal-with-godaddy/">github page 绑定 GoDaddy 的个人域名</a></p><h2 id="1-GoDaddy买一个域名"><a href="#1-GoDaddy买一个域名" class="headerlink" title="1.GoDaddy买一个域名"></a>1.GoDaddy买一个域名</h2><p>有手就行</p><h2 id="2-github-repository配置"><a href="#2-github-repository配置" class="headerlink" title="2.github repository配置"></a>2.github repository配置</h2><h3 id="新建一个github仓库"><a href="#新建一个github仓库" class="headerlink" title="新建一个github仓库"></a>新建一个github仓库</h3><ul><li><p>命名格式为<code>[随便一个名字].github.io</code>，例如<code>akaneovo.github.io</code>（之后都是拿这个作为例子）</p></li><li><p>设置为public，不然后面的github pages没有办法选择theme</p></li><li><p>选择<code>add a README file</code></p><p><img src="/img/image-20210221222049663.png" alt="image-20210221222049663.png"></p></li></ul><h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><ul><li><p>点击<code>Settings</code>，下拉到<code>GitHub Pages</code></p></li><li><p>点击<code>Change theme</code>选择一个Jekyll theme</p><p>如果之前自己写了<code>html</code>文件之类的还是要选，不然好像会404</p></li><li><p><code>Custom domain</code>里面填自己购买的域名</p><p><img src="/img/image-20210221223140725.png" alt="image-20210221223140725.png"></p></li></ul><h2 id="3-GoDaddy配置"><a href="#3-GoDaddy配置" class="headerlink" title="3.GoDaddy配置"></a>3.GoDaddy配置</h2><ul><li><p>选择<code>DNS</code></p><p><img src="/img/image-20210221223838993.png" alt="image-20210221223838993.png"></p></li></ul><ul><li><p>在<code>记录</code>部分添加两种记录</p><p><img src="/img/image-20210221223953867.png" alt="image-20210221223953867"></p><p>其中github IP可以在<a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">这里</a>获取</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>这四个随便哪一个都行</p></li></ul><h2 id="4-DNS设置"><a href="#4-DNS设置" class="headerlink" title="4.DNS设置"></a>4.DNS设置</h2><ul><li><p>打开<a href="https://www.dnspod.cn注册一个账号/">https://www.dnspod.cn注册一个账号</a></p></li><li><p>选择DNS解析，把自己买的域名添加进去</p></li><li><p>会提示GoDaddy的域名服务器和腾讯云的域名服务器不一样，打开GoDaddy域名配置的地方，使用自定义域名服务器</p><p><img src="/img/image-20210221224432853.png" alt="image-20210221224432853"></p></li><li><p>两个域名都复制腾讯云提示的域名服务器的地址，然后保存</p></li><li><p>点击添加的域名，类似于GoDaddy的配置，添加两条记录</p><p><img src="/images/image-20210221224612240.png" alt="image-20210221224612240"></p></li><li><p>保存之后点击域名设置-&gt;域名信息-&gt;健康诊断，看一下域名解析通不通过（我这边还是301，但是不知道为啥就是可以正常访问注册的域名了）</p><p><img src="/img/image-20210221224752104.png" alt="image-20210221224752104"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GithubPages </tag>
            
            <tag> Godaddy </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
