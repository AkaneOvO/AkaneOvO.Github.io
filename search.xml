<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何拥有自己的域名邮箱</title>
      <link href="p/c93f07dd.html"/>
      <url>p/c93f07dd.html</url>
      
        <content type="html"><![CDATA[<p><a href="39c58ade.html">前篇：Github Pages与个人域名绑定</a></p><p>我终于有自己的域名邮箱啦！！！<code>akaneovo@akaneovo.com</code>！！！快来给我写信！！！</p><p>问了下庚宝用的是<code>Yandex</code>的邮箱服务，于是也无脑整了个（</p><p><img src="/img/image-20210711153029646.png" alt="image-20210711153029646"></p><p>嘿嘿(:３っ)∋</p><p>Yandex要求的是<code>organization</code>（exp: aaakaneovo）持有这个域名，这个<code>organization</code>的<code>employee</code>才可以拥有这个域名作为后缀的邮箱。所以要先创建一个Yandex的账号作为你的<code>organization</code>账号，把域名添加进去，<code>verify</code>成功且配置好域名解析服务器上的DNS record后，再创建一个新的账号作为<code>employee</code>添加到<code>organization</code>里才可以创建<code>xxx@xxx.com</code>的邮箱</p><h2 id="1-Connect-a-domain"><a href="#1-Connect-a-domain" class="headerlink" title="1.Connect a domain"></a>1.Connect a domain</h2><p><a href="https://yandex.com/support/connect/add-domain.html">Yandex Support: Connect a domain</a></p><p>这一步按照官方的操作走就可以了（</p><p>在这一步里主要是创建了一个<code>organization manager</code>的账号，然后验证了你的域名是可用的，再把相关的DNS record更新到你的域名解析服务器上</p><h2 id="2-Create-an-employee-account"><a href="#2-Create-an-employee-account" class="headerlink" title="2.Create an employee account"></a>2.Create an employee account</h2><p><a href="https://yandex.com/support/connect/add-account.html">Yandex Support: Add employees</a>或者<a href="https://yandex.com/support/connect/create-mailbox.html">Yandex Support: Create a mailbox</a></p><img src="/img/image-20210711160301479.png" alt="image-20210711160301479" style="zoom:67%;" /><p>这一步还是按照官方的步骤走（</p><p>可以发现添加<code>new employee</code>的时候，<code>login</code>的邮箱就是你自己的域名后缀啦。创建好了这个员工账号之后，就可以使用这个员工账号里的邮箱作为你自己的个人邮箱来收件了。</p><p>同样可以使用该员工账号来登录Yandex，登录的账号为你的邮箱地址（exp: <a href="mailto:&#109;&#x79;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x40;&#97;&#107;&#x61;&#110;&#x65;&#x6f;&#118;&#111;&#46;&#x63;&#111;&#109;">&#109;&#x79;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x40;&#97;&#107;&#x61;&#110;&#x65;&#x6f;&#118;&#111;&#46;&#x63;&#111;&#109;</a>），密码就是在上图的表格里设置的密码。</p><p>用这个员工账户重新登录Yandex后，你就会发现自己右上角的名字变成了自己的邮箱</p><p><img src="/img/image-20210711160655786.png" alt="image-20210711160655786"></p><center>嚯嚯嚯，瓜瓜的新邮箱</center><p>现在，你就有了两个Yandex账号，一个是属于<code>organization</code>的，用来管理你的域名（也可以用来收件）；一个是你的<code>employee</code>账号，用来作为你的个人域名邮箱收件，别人发送到你的个人域名邮箱的邮件都会被发送到这个Yandex账号的收件箱里（也有可能在垃圾邮件堆里）。</p><h2 id="3-Configuring-desktop-email-clients"><a href="#3-Configuring-desktop-email-clients" class="headerlink" title="3.Configuring desktop email clients"></a>3.Configuring desktop email clients</h2><p><a href="https://yandex.com/support/mail/mail-clients/others.html">Yandex Support: Other mail clients</a></p><p>差不多也是跟着官方做，不过需要注意的是，需要在设置里面添加一个其他应用访问Yandex邮箱的密码</p><p><img src="/img/image-20210711162017694.png" alt="image-20210711162017694"></p><p>所以这一步要点进去<a href="https://yandex.com/support/id/authorization/app-passwords.html">Help for Yandex.Passport</a>，按照步骤在<code>Account Management</code>页面添加一个app访问mailbox的密码（它生成之后先不要点<code>Done</code>！！！等下在其他app里要用到！！！）</p><img src="/img/image-20210711162238763.png" alt="image-20210711162238763" style="zoom: 67%;" /><ul><li><p>outlook</p><p>如果配置的是outlook，就需要在添加账户时选择手动配置，服务选POP或IMAP，然后会到下图这个页面</p><img src="/img/image-20210711162554066.png" alt="image-20210711162554066" style="zoom:67%;" /><p>这里的密码填的就是刚刚生成的那个app password。</p><p>点其他设置，在发送服务器的tab那里把<code>我的发送服务器要求验证</code>勾上，然后在高级的tab那里填上官方说明的incoming mail和outcoming mail的server地址及端口号，<code>connection security</code>全部选<code>SSL</code></p><p><img src="/img/image-20210711162805680.png" alt="image-20210711162805680"></p><p>然后点下一步进行验证，全部通过之后就可以通过outlook代收你的个人域名邮箱的邮件了</p></li><li><p>win10自带邮箱</p><p>新建账户-&gt;其他账户-&gt;用你的个人域名邮箱和刚刚生成的密码登录即可</p><p>刚刚登录进去的时候邮箱里啥都没有，要点一下刷新进行同步</p></li><li><p>其他的邮箱和win10自带邮箱的绑定</p><p>一般都是先把该邮箱的POP3服务或者SMTP服务打开，获得/设置了第三方应用访问的密码之后，就可以在win10自带的邮箱上用该邮箱和生成的密码登录然后进行邮件同步啦。</p></li></ul><p>( •̀ ω •́ )自己的邮箱！好耶！</p>]]></content>
      
      
      <categories>
          
          <category> domain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yandex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS record相关</title>
      <link href="p/d6f8daa2.html"/>
      <url>p/d6f8daa2.html</url>
      
        <content type="html"><![CDATA[<p>因为晚上睡不着就去查了下当初部署博客的时候那些A记录到底是啥（</p><p><a href="39c58ade.html">之前的 将自己的域名和github博客链接起来的教程</a></p><p>一些链接：</p><p><a href="https://www.cloudflare.com/zh-cn/learning/dns/dns-records/">What is a DNS record?</a></p><p><a href="https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-a-record/">What is a DNS A record?</a></p><p><a href="https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-cname-record/">What is a DNS CNAME record?</a></p><p><a href="https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-mx-record/">What is a DNS MX record?</a></p><p><a href="https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-txt-record/">What is a DNS TXT record?</a></p><p><a href="https://www.cloudflare.com/zh-cn/learning/dns/dns-server-types/">DNS server types</a></p><blockquote><p>DNS records (aka zone files) are instructions that live in authoritative DNS servers and provide information about a domain including what IP address is associated with that domain and how to handle requests for that domain. These records consist of a series of text files written in what is known as DNS syntax. DNS syntax is just a string of characters used as commands that tell the DNS server what to do. All DNS records also have a TTL, which stands for time-to-live, and indicates how often a DNS server will refresh that record.</p></blockquote><ul><li><p>DNS记录就是放在DNS服务器上的一些命令，用来提供指定的域名对应的IP信息，以及处理访问该域名的请求</p></li><li><p>所有的DNS记录都会有一个生存时间TTL，当时间超过了TTL后，DNS服务器就需要刷新这条记录（具体的栗子后面说）</p></li></ul><p>常见的DNS记录：</p><h2 id="A-record"><a href="#A-record" class="headerlink" title="A record"></a>A record</h2><blockquote><p>The ‘A’ stands for ‘address’ and this is the most fundamental type of DNS record: it indicates the IP address of a given domain. For example, if you pull the DNS records of cloudflare.com, the A record currently returns an IP address of: 104.17.210.9.</p></blockquote><p><code>A</code>，即<code>address</code>，A记录是用来记录域名和服务器IP地址的对应关系，比如说我的<code>akaneovo.com</code>对应的是GITHUB的服务器IP，即，如果要访问这个域名，你要去问这个服务器IP，因为我的资源都在这个服务器上</p><blockquote><p>A records only hold IPv4 addresses. If a website has an IPv6 address, it will instead use an ‘AAAA’ record.</p></blockquote><p>（这里就不翻译啦）</p><p>A记录一般长这个样子</p><p><img src="/img/image-20210710183142023.png" alt="image-20210710183142023"></p><blockquote><p>The ‘@’ symbol in this example indicates that this is a record for the root domain, and the ‘14400’ value is the TTL , listed in seconds. The default TTL for A records is 14400 seconds. This means that if an A record gets updated, it takes 240 minutes (14400 seconds) to take effect.</p></blockquote><p><strong>注意</strong>：可以有很多个网站的A记录指向的是同一个IP地址，即，不同的域名对应着同一个服务器IP</p><h2 id="CNAME-record"><a href="#CNAME-record" class="headerlink" title="CNAME record"></a>CNAME record</h2><blockquote><p>The ‘canonical name’ (CNAME) record is used in lieu of an A record, when a domain or subdomain is an alias of another domain.</p></blockquote><p>CNAME记录用来记录的是A记录里面那个域名的别名，所有的CNAME记录都应该把一个域名映射到一个域名，而不是映射到一个IP地址上</p><p>比如说有一个CNAME记录将<code>blog.example.com</code>映射到了<code>example.com</code>，那么在浏览器地址栏输入<code>blog.example.com</code>的时候DNS服务器会去找它对应的<code>example.com</code>所对应的IP地址（也就是<code>example.com</code>的A记录里的内容），因此可以说，<code>blog.example.com</code>是<code>example.com</code>的别名</p><p>使用CNAME记录和A记录的一个很大的好处就是，如果我这个网站有好多个别名，就会对应很多个CNAME记录，他们都指向了同一个域名，这个域名的A记录保存的是服务器的IP地址。那如果有一天原来的服务器炸了，我要临时换服务器，就只需要改A记录的服务器IP地址，就可以让这个域名和它所有的别名都指向了那个新的服务器。如果只有A记录的话，就要一个一个的改嗷。</p><p><strong>注意</strong>：虽然两个域名最终指向的是同一个IP地址，但是实际上访问的也可以是不同的页面。因为在服务器上还会对url进行处理( •̀ ω •́ )</p><p>CNAME记录一般长这个样子：</p><p><img src="/img/image-20210710190017996.png" alt="image-20210710190017996"></p><p>虽然CNAME记录允许指向另一个CNAME记录，但是这样效率很低，为啥不直接指向一个A记录呢（</p><h2 id="MX-record"><a href="#MX-record" class="headerlink" title="MX record"></a>MX record</h2><blockquote><p>A DNS ‘mail exchange’ (MX) record directs email to a mail server. The MX record indicates how email messages should be routed in accordance with the Simple Mail Transfer Protocol (SMTP, the standard protocol for all email). Like CNAME records, <strong>a MX record must always point to another domain</strong>.</p></blockquote><p><code>MX</code>，即<code>Mail Exchange</code>，主要是将以本域名结尾的电子邮件定向到邮件交换服务器，比如说，把发送给<code>akane@akaneovo.com</code>的邮件根据MX record的value值使用SMTP协议发送到对应的邮件服务器上</p><p>MX记录长这个样子：</p><p><img src="/img/image-20210710225149510.png" alt="image-20210710225149510"></p><p><code>priority</code>域的值越小，该邮件服务器的使用优先级越高。上面这个栗子里，优先使用<code>mailhost1.example.com</code>，如果往这个邮件服务器上发邮件失败了，才会往<code>mailhost1.example.com</code>上发邮件</p><h2 id="NS-record"><a href="#NS-record" class="headerlink" title="NS record"></a>NS record</h2><p><code>NS</code>即域名服务器，说明了哪个服务器包含了实际的DNS记录（那个服务器对该域名具有权威性）。一个域名通常会有多个NS记录，这些记录可以指示该域名的主要和备用域名服务器。互联网可以在这些域名服务器上找到对应的IP地址。</p><p>NS记录不能指向CNAME记录</p><h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><p>域名服务器是一种DNS服务器，上面存储了所有的DNS记录，包括A记录、MX记录以及CNAME记录等</p><h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><p><img src="/img/image-20210711135111652.png" alt="image-20210711135111652"></p><p>所有的DNS服务器都属于以下四个类别之一：</p><ul><li><p>递归解析器</p><blockquote><p>从 Web 客户端收到 DNS 查询后，递归解析器将使用缓存的数据进行响应，或者将向根域名服务器发送请求，接着向 TLD 域名服务器发送另一个请求，然后向权威性域名服务器发送最后一个请求。<strong>收到来自包含已请求 IP 地址的权威性域名服务器的响应后</strong>，递归解析器将向客户端发送响应。</p><p>在此过程中，递归解析器将缓存从权威性域名服务器收到的信息。当一个客户端请求的域名 IP 地址是另一个客户端最近请求的 IP 地址时，解析器可绕过与域名服务器进行通信的过程，并仅从第二个客户端的缓存中为第一个客户端提供所请求的记录。</p></blockquote></li><li><p>根域名服务器</p><blockquote><p>每个递归解析器都知道 13 个 DNS 根域名服务器，它们是递归解析器搜寻 DNS 记录的第一站。根服务器接受包含域名的递归解析器的查询，根域名服务器根据该域的扩展名（.com、.net、.org 等），通过将递归解析器定向到 TLD 域名服务器进行响应。</p></blockquote></li><li><p>TLD域名服务器</p><blockquote><p>TLD 域名服务器维护共享通用域扩展名的所有域名的信息，例如 .com、.net 或 url 中最后一个点之后的任何内容。例如，.com TLD 域名服务器包含以“.com”结尾的每个网站的信息。</p></blockquote></li><li><p>权威域名服务器</p><blockquote><p>当递归解析器收到来自 TLD 域名服务器的响应时，该响应会将解析器定向到权威性域名服务器。权威性域名服务器通常是解析器查找 IP 地址过程中的最后一步。权威名称服务器包含特定于其服务域名的信息（例如，google.com）,并且它可为递归解析器提供在 DNS A 记录中找到的服务器的 IP 地址，或者<strong>如果该域具有 CNAME 记录，它将为递归解析器提供一个别名域，这时递归解析器将必须执行全新 DNS 查找</strong>，以便从权威性域名服务器获取记录（通常为包含 IP 地址的 A 记录）。</p></blockquote></li></ul><h3 id="ICANN"><a href="#ICANN" class="headerlink" title="ICANN"></a>ICANN</h3><p>因为很好奇我买了域名，在购买了域名的网站上填写了Nameservers的地址之后，为啥TLD域名服务器就知道我的<code>akaneovo.com</code>的权威域名服务器地址了，所以问了下庚宝，说是因为买了域名之后看账单可以看到这么个东西</p><p><img src="/img/image-20210711164810296.png" alt="image-20210711164810296"></p><p><a href="https://en.wikipedia.org/wiki/ICANN">WIKIPEDIA: ICANN</a></p><p><a href="https://www.cloudflare.com/learning/dns/glossary/what-is-a-domain-name-registrar/">What is a domain name registrar</a></p><p>相当于卖给我域名的网站是个<code>registrar</code>（中间商），而受ICANN和IANA管理的<code>registry</code>才是制造商。上面付的2.34刀就是中间商要给制造商的价格，这样ICANN就会帮我把有关我的<code>akaneovo.com</code>的记录更新到相应的服务器上了。</p><p>ICANN把我的<code>akaneovo.com</code>对应权威域名服务器（也就是那个dnspod的服务器）的dns record放到了<code>.com</code>的TLD域名服务器上，大概长成下面这个样子（<a href="https://avinetworks.com/docs/18.2/ns-records-in-avi-dns/">这张图片的来源</a>）：</p><p><img src="/img/image-20210711235726275.png" alt="image-20210711235726275"></p><blockquote><p>The above configuration for a static NS record is for the domain “avi.com,” which has NS records pointing to two name servers. Thus, any DNS query with the subdomain “avi.com” that comes to this server will be served the NS records in the AUTHORITY SECTION of the DNS response. This response will cause a recursive name resolver to direct the DNS query to either of the two name servers. Thus, a query for A record for <a href="http://www.avi.com/">www.avi.com</a> will get a response of two NS records in the DNS response along with the glue record for ns1.avi.com in the ADDITIONAL SECTION of the response. The recursive resolver will then send the same DNS query to the name server ns1.avi.com or ns2.avi.net.</p></blockquote><p>所以如果我的递归解析器（recursive name resolver）想要查找我的<code>akaneovo.com</code>对应的A记录，就先会在<code>.com</code>对应的TLD域名服务器上得到两个NS record（记录着dnspod两个服务器的域名），然后递归解析器再去查找这两个服务器的A记录，得到ip之后，才可以知道走到了<code>.com</code>之后去哪里找我的<code>akaneovo.com</code>（但是如果服务器有缓存的话，查找了一次之后，下一次就可以直接在本地缓存里拿IP，就不用麻烦递归解析器啦）</p><h2 id="TXT-record"><a href="#TXT-record" class="headerlink" title="TXT record"></a>TXT record</h2><blockquote><p>The DNS ‘text’ (TXT) record lets a domain administrator enter text into the Domain Name System (DNS). The TXT record was originally intended as a place for human-readable notes. However, now it is also possible to put some machine-readable data into TXT records. One domain can have many TXT records.</p></blockquote><p>TXT record主要是用来放人看的文本的，但是也可以放机器看的文本</p><blockquote><p>Today, two of the most important uses for DNS TXT records are email spam prevention and domain ownership verification, although TXT records were not designed for these uses originally.</p></blockquote><p>现在TXT record主要用来做垃圾邮件过滤和域名所有权认证（虽然TXT record最初设计的本意并不是这样）</p><p>TXT record长这个样子</p><p><img src="/img/image-20210711144010868.png" alt="image-20210711144010868"></p><h2 id="关于之前把自己的博客和域名关联起来"><a href="#关于之前把自己的博客和域名关联起来" class="headerlink" title="关于之前把自己的博客和域名关联起来"></a>关于之前把自己的博客和域名关联起来</h2><p>（看了下好像其实完全可以不用做godaddy配置A记录和CNAME记录的操作，直接用dnsPod配置就好了。因为实际上最后我的域名是交给dnsPod的服务器做解析的，所以A记录和CNAME记录应该是放在dnsPod的DNS服务器上。如果我的域名是交给godaddy自己做解析的话，那就在godaddy上配A记录和CNAME记录）</p>]]></content>
      
      
      <categories>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM architecture</title>
      <link href="p/d0646389.html"/>
      <url>p/d0646389.html</url>
      
        <content type="html"><![CDATA[<p>终于补了之前一直拖着没看的JVM architecture…</p><p>参考：</p><p><a href="https://www.oracle.com/java/technologies/security-in-java.html">The Byte Code Verification Process</a></p><p><a href="https://www.youtube.com/watch?v=QHIWkwxs0AI">YouTube: JVM Architecture</a></p><p><a href="https://en.wikipedia.org/wiki/Java_Classloader">WIKIPEDIA: Java Classloader</a></p><p><a href="https://en.wikipedia.org/wiki/Java_virtual_machine">WIKIPEDIA: Java Virtual Machine</a></p><p><a href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/">geeksforgeeks: How JVM Works - JVM Architecture?</a></p><p><a href="https://www.oracle.com/java/technologies/security-in-java.html">Oracle: The Java Language Environment</a></p><p><a href="https://www.geeksforgeeks.org/java-memory-management/">geeksforgeeks: Java Memory Management</a></p><p><a href="http://www.herongyang.com/JVM/Stack-Overflow-What-Is-JVM-Stack.html">What is JVM Stack</a></p><p><a href="https://www.geeksforgeeks.org/java-virtual-machine-jvm-stack-area/">geekforgeeks: JVM Stack Area</a></p><p><a href="https://codeahoy.com/2017/08/06/basics-of-java-garbage-collection/">basics of java garbage collection</a></p><p>自己画了个图(っ´Ι`)っ<br><img src="/img/JVM.png" alt="JVM"></p><h2 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h2><h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><blockquote><p>The <strong>Java Class Loader</strong> is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine. Usually classes are only loaded on demand.</p><p>The Class loader reads the “.<em>class”</em> file, generate the corresponding binary data and save it in the method area.</p></blockquote><ul><li><p>bootstrap class loader：loads the core java libraries located in the <code>&lt;JAVA_HOME&gt;/jre/lib</code> directory，例如使用<code>System.out.println(&quot;hello&quot;)</code>时需要导入<code>java.lang</code>，就是由<code>bootstrap loader</code>通过导入<code>rt.jar</code>包实现的</p></li><li><p>extension class loader：loads the code in the extensions directories (<code>&lt;JAVA_HOME&gt;/jre/lib/ext</code>,[<a href="https://en.wikipedia.org/wiki/Java_Classloader#cite_note-TJT:UECL-3">3]</a> or any other directory specified by the <code>java.ext.dirs</code> system property). 例如使用了<code>jdbc</code>和数据库进行连接，就需要使用到<code>extension class loader</code></p></li><li><p>system/application class loader：用来导入自己写的<code>.java</code>转成的<code>.class</code>文件</p></li></ul><blockquote><p><strong>Note:</strong> JVM follows the Delegation-Hierarchy principle to load classes. System class loader delegate load request to extension class loader and extension class loader delegate request to the bootstrap class loader. If a class found in the boot-strap path, the class is loaded otherwise request again transfers to the extension class loader and then to the system class loader. At last, if the system class loader fails to load class, then we get run-time exception <em>java.lang.ClassNotFoundException</em>. </p></blockquote><p>大概是说，load class的时候是从bootstrap classloader开始一层层向下进行委托，即，bootstrap loader先拜托extension classloader，extension loader再拜托application classloader在自己的路径下查找，如果没有在自己的路径下找到对应的class，再由它的上一级在自己对应的目录下查找，如果找了一圈都没有找到，我们就会得到<code>java.lang.ClassNotFoundException</code></p><h3 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h3><ul><li><p>verification</p><p>用于确保字节码文件符合标准，如果在verification的时候fail了，就会得到<code>runtime exception java.lang.VerifyError</code></p><p>这个过程由<code>ByteCodeVerifier</code>完成</p><blockquote><p>The bytecode verifier acts as a sort of gatekeeper: it ensures that code passed to the Java interpreter is in a fit state to be executed and can run without fear of breaking the Java interpreter. Imported code is not allowed to execute by any means until after it has passed the verifier’s tests.</p><p>Once the verifier is done, a number of important properties are known:</p><ul><li>There are no operand stack overflows or underflows</li><li>The types of the parameters of all bytecode instructions are known to always be correct</li><li>Object field accesses are known to be legal–private, public, or protected</li></ul></blockquote></li><li><p>preparation</p><p>为变量预先分配内存空间</p><blockquote><p>allocates memory for class variables and initializing the memory to default values</p></blockquote></li><li><p>resolution</p><p>没太懂，好像是说把符号引用变成直接引用（但是符号引用是个啥不知道</p><blockquote><p>transforms symbolic references from the type into direct references.</p></blockquote></li></ul><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>自上而下，自父类到子类为静态变量赋值</p><blockquote><p>In this phase, all static variables are assigned with their values defined in the code and static block(if any). This is executed from top to bottom in a class and from parent to child in the class hierarchy.</p></blockquote><h2 id="Runtime-Memory-Data"><a href="#Runtime-Memory-Data" class="headerlink" title="Runtime Memory Data"></a>Runtime Memory Data</h2><h3 id="Heap-Area"><a href="#Heap-Area" class="headerlink" title="Heap Area"></a>Heap Area</h3><ul><li><p><strong>a shared runtime area</strong> and stored the actual object in memory</p><p>it’s instantiated during the virtual machine startup, <strong>the memory is allocated for all class instances and array</strong></p></li><li><p>can be of <strong>fixed or dynamic size</strong> depending upon the system’s configuration</p></li><li><p>provides the user control to initialize or vary the size of heap as per requirement</p></li><li><p><strong>when a new keyword is used, objects is assigned a space in heap, but the reference of the same exists onto the stack</strong></p></li><li><p>there exists one and only one heap for a running JVM process</p></li><li><p><strong>garbage collection</strong> in heap area is <strong>mandatory</strong></p></li></ul><h4 id="eden-space"><a href="#eden-space" class="headerlink" title="eden space"></a>eden space</h4><ul><li>bigger than two survivor spaces combined</li><li>all objects are first created here</li><li>when eden space is full, a minor garbage collection is triggered, all new objects are quickly inspected to check their eligibility for garbage collection. The ones are not referenced from other objects are marked as dead and garbage collected, the survivor objects are moved to one of the empty survivor spaces</li></ul><h4 id="survivor-space"><a href="#survivor-space" class="headerlink" title="survivor space"></a>survivor space</h4><p>why have two survivor space?</p><ul><li>to avoid memory fragment</li><li>after garbage collection, this will leave holes in memory where the dead objects previously lived and compaction will be needed</li><li>to avoid compaction, JVM just copied surviving objects from the survivor space to the other survivor space so there is no holes or empty spaces</li></ul><h4 id="tenured-space"><a href="#tenured-space" class="headerlink" title="tenured space"></a>tenured space</h4><p>minor garbage collections ping-ping live objects from eden and one of the survivor space to the other, objects moved to the old generation until one of the following happens:</p><ul><li>Objects reach <em>maximum tenuring threshold</em>, in other words, have ping-pong’ed enough times that they aren’t young anymore</li><li>There is no room in survivor space to receive newly birthed objects</li></ul><blockquote><p>the old generation is used to store long-lived objects, eventually, the old generation also needs to be garbage collected and this is called <strong>major garbage collection</strong></p></blockquote><p><strong>总结</strong>：对于<code>eden space</code>每次满的时候都会做一次<code>minor garbage collection</code>，从这次垃圾回收中存活下来的object会被放到<code>survivor space</code>里去，当<code>survivor space</code>被放满的时候，也会有一次<code>minor garbage collection</code>，将它里面的object进行整理，放到另一个空的<code>survivor space</code>里。一个object每活过一次<code>minor garbage collection</code>就会变老，它变老会有个上限<code>threshold</code>，当达到这个值时就会被放到<code>tenured space</code>里；或者当<code>survivor space</code>里面已经没有空间来放入新生的objects的时候，也会将一些object放到<code>tenured space</code>里面。</p><h4 id="permanent-space"><a href="#permanent-space" class="headerlink" title="permanent space"></a>permanent space</h4><blockquote><p>The pool containing all the reflective data of the virtual machine itself, such as class and method objects</p></blockquote><h3 id="Method-Area"><a href="#Method-Area" class="headerlink" title="Method Area"></a>Method Area</h3><ul><li>a logical part of the heap</li><li>This memory is <strong>allocated for class structures, method data and constructor filed data, and also for interfaces or special method used in class</strong></li><li>can be of a fixed size or expanded as required by the computation, needs not to be continuous</li><li>Though method area is logically a part of heap, <strong>it may or may not be garbage collected even if garbage collection is compulsory in heap area.</strong></li></ul><h3 id="JVM-Stack"><a href="#JVM-Stack" class="headerlink" title="JVM Stack"></a>JVM Stack</h3><ul><li>a stack <strong>is created at the same time when a thread is created</strong> and is used to store data and partial results</li><li>can either be of fixed or dynamic size, need not to be continuous</li></ul><h4 id="stack-frames"><a href="#stack-frames" class="headerlink" title="stack frames"></a>stack frames</h4><blockquote><p>A JVM stack data area is actually organized as a stack of frames</p></blockquote><p>a life cycle of a frame</p><ul><li>a new frame is created when a new method is invoked</li><li>the new frame is added to the top of the stack with the execution control is transferred to the new method</li><li>the new frame is used during the execution of the new method to store local variables, partial results, and data for subsequent method invocations and returns</li><li>the new frame is removed from the top of the stack when the execution control is returned from the new method</li></ul><p>stack frame structure</p><ul><li>Local Variable Array（LVA）<ul><li>contains all parameters and local variables of the method</li><li>each slot in the array is 4 Bytes</li><li>int、float and reference occupy 1 slot</li><li>float、double and long occupy 2 slot</li><li>byte、short and char values will be converted to int type before storing</li><li>the way of storing boolean values is varied from JVM to JVM, usually 1 slot</li><li>the parameters are placed into the local variable array according to the order they are declared</li></ul></li><li>Operand Stack（OS）<ul><li>the operand stack is organized as an array of words like LVA, but this is not accessed by using an index, it’s accessed by some instructions that can push or pop values from the operand stack</li></ul></li><li>Frame Data（FD）<ul><li>contains all symbolic references (constant pool resolution) and normal method returns related to that particular method</li><li>contains a reference to the Exception table which provides the corresponding catch block information in the case of exceptions</li></ul></li></ul><h4 id="StackOverFlowError"><a href="#StackOverFlowError" class="headerlink" title="StackOverFlowError"></a>StackOverFlowError</h4><blockquote><p>A StackOverflowError is an exception thrown by a thread, when it’s stack has no more room to add a new frame to make the next method call.</p></blockquote><h3 id="Native-Method-Stack"><a href="#Native-Method-Stack" class="headerlink" title="Native Method Stack"></a>Native Method Stack</h3><ul><li>not written in java language</li><li>this memory is allocated for each thread when its created</li></ul><h3 id="PC-Registers"><a href="#PC-Registers" class="headerlink" title="PC Registers"></a>PC Registers</h3><ul><li>each JVM thread which carries out the task of a specific method has a program counter register associated with it</li><li>PC register is capable of storing the return address or a native pointer on some specific platform</li></ul><h2 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h2><blockquote><p>Each thread of a running application is a distinct instance of the virtual machine’s execution engine. Execution engine executes the byte code which is assigned to the run time data areas in JVM via class loader. Java Class files are executed by the execution engine.</p></blockquote><h3 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h3><blockquote><p>It reads the byte code and interprets into the machine code(native code) and executes them in a sequential manner.</p><p>The problem with the interpreter is that it interprets every time, even the same method multiple times, which reduces the performance of the system</p></blockquote><h3 id="Just-In-Time-Compiler-JIT"><a href="#Just-In-Time-Compiler-JIT" class="headerlink" title="Just-In-Time Compiler(JIT)"></a>Just-In-Time Compiler(JIT)</h3><blockquote><p>balances the interpreter’s disadvantage of slow execution and improves the performance</p></blockquote><h3 id="Garbage-Collector"><a href="#Garbage-Collector" class="headerlink" title="Garbage Collector"></a>Garbage Collector</h3><h4 id="Garbage-Collection-Algorithms"><a href="#Garbage-Collection-Algorithms" class="headerlink" title="Garbage Collection Algorithms"></a>Garbage Collection Algorithms</h4><ul><li>serial collector<ul><li>uses a single thread to perform all garbage work</li><li>relatively efficient, because there is no communication overhead between threads</li><li>best-suited to single processor machines</li></ul></li><li>parallel collector<ul><li>known as the throughput collector</li><li>can significantly reduce garbage collection overhead</li><li>intended for applications with medium-sized to large-sized data sets that are run on multiprocessor or multithread hardware</li></ul></li><li>concurrent collector<ul><li>keep garbage collection pause short</li><li>It is designed for applications with medium-sized to large-sized data sets in which response time is more important than overall throughput because the techniques used to minimize pauses can reduce application performance</li></ul></li></ul><p>HotSpot JVM allows you to configure separate GC algorithms for young and old generations. But you can only <strong>pair up compatible</strong> algorithms. </p><h4 id="Mark-and-Sweep-Algorithm"><a href="#Mark-and-Sweep-Algorithm" class="headerlink" title="Mark and Sweep Algorithm"></a>Mark and Sweep Algorithm</h4><p>it contains two phases</p><ul><li><p>mark phase</p><p>It identifies and marks all objects that are in use, and the remaining can be considered garbage.</p></li><li><p>sweep phase</p><p>In this phase, the heap is traversed to find the gap between the live objects. These gaps are recorded in the free list and are available for new object allocation.</p></li></ul><h3 id="Java-Native-Interface-JNI"><a href="#Java-Native-Interface-JNI" class="headerlink" title="Java Native Interface(JNI)"></a>Java Native Interface(JNI)</h3><blockquote><p>JNI acts as a bridge between java method calls and corresponding native libraries</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AE插件相关</title>
      <link href="p/4a47d5cc.html"/>
      <url>p/4a47d5cc.html</url>
      
        <content type="html"><![CDATA[<h2 id="AE插件安装"><a href="#AE插件安装" class="headerlink" title="AE插件安装"></a>AE插件安装</h2><p>插件压缩包下载下来解压应该是一个<code>aex</code>或者一堆<code>aex</code>文件，打开<code>C:\Program Files\Adobe\Common\Plug-ins\7.0\MediaCore</code>，新建一个文件夹，然后把那一堆<code>aex</code>文件丢进去，重启AE的时候在<code>效果</code>的地方就可以看到新添加的插件了</p><p><img src="/img/aeplugin_exp.png" alt="aeplugin_exp"></p><p><strong>注意：</strong>如果是自己添加的插件有可能会需要注册，在把<code>aex</code>文件放进去之后打开ae，如果发现用了这个插件后屏幕上多了一个大红叉，说明你没有注册，需要点击这个插件右上角的<code>register</code>输入序列号注册</p><h2 id="插件及使用"><a href="#插件及使用" class="headerlink" title="插件及使用"></a>插件及使用</h2><blockquote><p>学啥用啥，不定期更新，参数可以多试试，下面写的也不是全部</p></blockquote><h3 id="Particular"><a href="#Particular" class="headerlink" title="Particular"></a>Particular</h3><blockquote><p>很好康的粒子效果，还可以让粒子展示成子图层的样子用来变换粒子的形状</p></blockquote><p>一般要改的参数：</p><ul><li><p>发射器</p><ul><li>发射器类型：点-&gt;方盒</li><li>速度及以下四个选项：全0</li><li>发射大小：自行调整，一般覆盖整个要展示的页面即可</li><li>随机种子：生成随机粒子分布用的</li></ul></li><li><p>粒子</p><ul><li><p>生命：不然移动一下游标就发现粒子全没了，值越大粒子保持时间越久</p></li><li><p>粒子类型</p><ul><li><p>子画面</p><p>可以新建一个合成把多个不同的文字排成序列</p><img src="/img/image-20210517204449937.png" alt="image-20210517204449937"  /><p>然后把这个合成拖到当前正在制作的合成里面，选择了粒子类型为子画面之后，就可以选择纹理为刚刚拖进来的那个合成</p></li><li><p>发光球体</p><p>好康的点点</p></li></ul></li><li><p>大小随机：选择了子画面之后可以改改，可以把每个粒子的大小变一下</p></li><li><p>旋转：让粒子转转，看起来不要那么整齐</p></li></ul></li><li><p>物理学</p><ul><li>重力：粒子轻微上浮，蛮好看的</li></ul></li></ul><h3 id="RealGlow"><a href="#RealGlow" class="headerlink" title="RealGlow"></a>RealGlow</h3><blockquote><p>比AE自带的发光要好看的发光效果</p></blockquote><p>一般要改的参数：</p><ul><li>辉光半径：默认的是100，亮瞎我，自行降低</li><li>辉光强度：同上，默认是1</li><li>不相乘：默认不勾选，建议勾上，不然加了辉光之后其他图层就被遮住了</li></ul><h3 id="音频频谱"><a href="#音频频谱" class="headerlink" title="音频频谱"></a>音频频谱</h3><blockquote><p>AE自带用于生成音频频谱</p></blockquote><p>选择音频层为添加的音乐后，在添加了音频频谱的层上面再加一层蒙版，把路径选成那个蒙版就可以改成自己想要的形状了</p><p>一般要改的参数：</p><ul><li>音频层：这个音频频谱基于哪段音乐</li><li>路径：可以改变频谱形状，基于本合成中的某个蒙版</li><li>起始频率和终止频率：范围调小可以让波形都在一个范围内</li><li>最大高度</li><li>内部颜色和外部颜色</li><li>显示选项<ul><li>数字：类似喷泉</li><li>模拟谱线：心电图</li><li>模拟频点：点</li></ul></li><li>面选项</li></ul><h2 id="一些成果"><a href="#一些成果" class="headerlink" title="一些成果"></a>一些成果</h2><h3 id="3D空间"><a href="#3D空间" class="headerlink" title="3D空间"></a>3D空间</h3><p>Particular+RealGlow and so on</p><p><a href="https://www.bilibili.com/video/BV1bs411q7t9">原教程地址</a>，偷懒阉割了背景和辉光的效果</p><video width="480" height="320" controls><source src="/img/三维.mp4"></video><h3 id="频谱"><a href="#频谱" class="headerlink" title="频谱"></a>频谱</h3><p>音频频谱+生成-&gt;圆形 and so on</p><p><a href="https://www.bilibili.com/video/BV1Cs411R762">原教程地址</a></p><video width="480" height="320" controls><source src="/img/频谱2.mp4"></video>]]></content>
      
      
      <categories>
          
          <category> AE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django学习笔记</title>
      <link href="p/18f130f7.html"/>
      <url>p/18f130f7.html</url>
      
        <content type="html"><![CDATA[<p>因为数据库实验要自己写一个阉割版的微博，就顺带去把django学了</p><p><a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django">参考：MDN的快乐教程</a></p><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><blockquote><p>Django refers to this organization as the “Model View Template (MVT)” architecture. It has many similarities to the more familiar <a href="https://developer.mozilla.org/en-US/docs/Glossary/MVC">Model View Controller</a> architecture. </p></blockquote><p>M：Model，负责对数据的处理</p><p>V：View，负责处理用户的请求，调用Model和Template响应请求</p><p>T：Template，负责如何显示数据</p><p>MVT和设计模式里的MVC有一些不一样的地方</p><ul><li><p>MVC中，C为Controller，M和V和MVT中的含义一样</p></li><li><p>MVT模式中的M感觉更专注于对于特定url的处理，而Controller还要额外负责对url的映射。这一部分的功能MVT则使用了一个单独的UrlMapper来完成</p></li><li><p>Django的MVT模式中的View扩展了一些功能，能够使用模板来实现前端页面的复用</p></li></ul><p>按照MVT设计模式的思想，一个Django Application大概就长成这样</p><img src="/img/django.jpg" alt="django" style="zoom:80%;" /><p>具体的执行顺序为：</p><p>（中间件还没学过俺们先跳过这部分）</p><ul><li>客户端发出请求，在地址栏里面输入要访问的url地址</li><li>URLMapper收到了这个url地址后找到对应的View来进行处理</li><li>在该url对应的view中可以通过models来访问数据库取得需要的信息</li><li>通过models获得数据库中的信息返回给view之后，渲染template</li><li>将渲染完的template展示给用户</li></ul><h2 id="django项目结构"><a href="#django项目结构" class="headerlink" title="django项目结构"></a>django项目结构</h2><p>嘛，先要把django和python装上再说</p><p>MDN上让我弄个虚拟环境，头铁直接装在本地了，不过看起来问题不大的样子</p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>python就不教怎么装了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -V # 检查python版本,尽量和最新版本的django适配</span><br></pre></td></tr></table></figure><p>安装django</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py -m pip install Django # 不过我好像是直接pip install Django装上的，看起来问题不大</span><br></pre></td></tr></table></figure><p>安装好之后check一下版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m django --version # 个人的是3.0.8</span><br></pre></td></tr></table></figure><p>然后就可以新建一个项目啦</p><p><a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/development_environment#installing_django">因为实在懒得一步步写所以把官方链接放上来.jpg</a></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>知道了django Application的基本架构之后，看它的项目结构就会清晰好多了</p><p><img src="/img/image-20210406112444053.png" alt="image-20210406112444053"></p><p>嘛，照着官方的新建完，刚开始的项目结构就是长成这个样子</p><ul><li><code>urls.py</code>就是上面说的urlMapper，用来配置url和view的映射</li><li><code>settings.py</code>里面可以配置新安装的模块、中间件、template的路径、使用的数据库、静态资源文件所在目录等信息</li><li><code>manage.py</code>每次我们都用它来<code>runserver</code>或者做一些其他的操作，是默认生成的</li><li><code>__init__.py</code>说明这是一个python包</li></ul><p>按照前面架构图里流程走一遍呗</p><h4 id="urls-py"><a href="#urls-py" class="headerlink" title="urls.py"></a>urls.py</h4><p>我们知道一个请求发过来的时候要由<code>url Mapper</code>做处理，所以可以修改<code>urls.py</code>，让它将不同的<code>url</code>映射到不同的<code>view</code>上做处理</p><p>有几种配置的方式</p><ul><li><p><code>path(&#39;index/&#39;,views.Myview,name=&#39;index&#39;)</code></p><p>说明对于<code>url</code>格式为<code>index/</code>的，使用和<code>urls.py</code>同级目录下的<code>views.py</code>里的<code>Myview</code>方法来处理，<code>name=&#39;index&#39;</code>是为了之后在template里面使用这个url可以直接用它的这个别名</p><p>比如说<code>&lt;a href=&quot;&#123;% url 'index' %&#125;&quot;&gt;Home&lt;/a&gt;</code></p></li><li><p><code>path(&#39;myapp/&#39;,include(&#39;app.urls&#39;))</code></p><p>对于<code>url</code>开头格式为<code>app/</code>的，剩下<code>url</code>的处理要去同级目录的<code>app</code>文件夹下的<code>urls.py</code>里处理</p><p>我们可以在一个项目里分成很多个模块，每个模块都是一个文件夹</p><p>要创建一个模块，需要在<code>manage.py</code>的同级目录下执行命令<code>python manage.py startapp yourappname</code>，然后你的项目目录就会变成这个样子</p><img src="/img/image-20210406113826223.png" alt="image-20210406113826223" style="zoom:80%;" /><p>这里的<code>myapp</code>就是我新创建的模块</p><p>创建了一个新模块之后，需要将它注册到整个django application里面，也就是修改<code>settings.py</code>，往<code>INSTALLED_APPS</code>里面加上一行<code>yourappname.apps.yourappnameConfig</code>（如果不确定的话，可以打开新建的模块里的<code>apps.py</code>，把里面的那个<code>xxxConfig</code>给抄进去）</p><p>我们可以发现在你新创建的模块文件夹里面也有一个<code>urls.py</code>，联想上面说的那个<code>include(&#39;app.urls&#39;)</code>的配置，我们在这个模块的<code>urls.py</code>里面加上<code>path(&#39;index/&#39;,views.Myview,name=&#39;my_index&#39;)</code>，总的来看，就是当输入的<code>url</code>为<code>/myapp/index</code>时，查找这个模块里的<code>views.py</code>里的<code>Myview</code>方法来进行处理</p></li><li><p><code>path(&#39;authors&#39;,views.AuthorListView.as_view(),name=&#39;authors&#39;)</code></p><p>对于<code>url</code>格式为<code>authors</code>的，要去找<code>view.AuthorListView</code>进行处理，但是这个<code>as_view</code>是个啥东西？</p><p>如果是这样写，一般这个<code>view</code>是继承了<code>django.views.generic.ListView</code>或者<code>DetailView</code>，主要是用来展示数据库里的信息</p><p>这个<code>view</code>一般长成这样子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorListView</span>(<span class="params">generic.ListView</span>):</span></span><br><span class="line">    model = Author</span><br><span class="line">    context_object_name = <span class="string">&#x27;my_author_list&#x27;</span><span class="comment"># your own name for the list as a template variable</span></span><br><span class="line">    queryset = Book.objects.<span class="built_in">filter</span>(title__icontains=<span class="string">&#x27;akane&#x27;</span>)[:<span class="number">5</span>]<span class="comment"># Get 5 authors containing the title akane</span></span><br><span class="line">    template_name = <span class="string">&#x27;authors/my_arbitrary_template_name_list.html&#x27;</span><span class="comment"># Specify your own template name/location</span></span><br><span class="line">    paginate_by = <span class="number">10</span> <span class="comment"># 一页10个数据</span></span><br></pre></td></tr></table></figure><p>它对应的<code>html</code>文件的命名如果没有像上面一样修改<code>template_name</code>，则已经事先规定好了，在上面这个栗子中，因为传入的<code>model=Author</code>，因此这个<code>html</code>文件的默认命名为<code>author_list.html</code>，即：<code>modelname_list.html</code></p><p><strong>注意</strong>：像上面这种<code>template</code>的<code>html</code>文件，一般是放在<code>template</code>目录下的和模块名同名的目录下的。举个栗子，我们有个模块叫<code>catalog</code>，那么这些<code>XXXListView</code>或者<code>XXXDetailView</code>的<code>html</code>文件应该放在<code>catalog/templates/catalog</code>目录下</p><p><img src="/img/image-20210406154855008.png" alt="image-20210406154855008"></p><p>在<code>html</code>中要以数据库中的信息作为变量拿到，默认是通过<code>modelname_list</code>来拿到的，或者我们可以像上面的栗子一样自定义<code>context_object_name</code>，这就是我们在<code>template</code>中使用的变量的名称</p></li><li><p><code>path(&#39;author/&lt;int:pk&gt;&#39;, views.AuthorDetailView.as_view(), name=&#39;author-detail&#39;)</code></p><p>在<code>author/</code>的基础上加了一个值，主要是用来展示数据库中单个model的详细信息的，后面的<code>&lt;int:pk&gt;</code>用来指明需要查找的数据库中的哪一个元组</p><p>其中<code>view</code>和之前说过的<code>ListView</code>差不多，区别在于继承的是<code>django.views.generic.DetailView</code>，写法和<code>ListView</code>也几乎一样</p><p><code>DetailView</code>对应的<code>html</code>文件默认命名为<code>modelname_detail.html</code>，在<code>template</code>中获取变量的名字和<code>modelname</code>是一样的</p></li><li><p><code>path(&#39;admin/&#39;,admin.site.urls)</code></p><p>说明对于<code>url</code>格式为<code>admin/</code>的，需要使用<code>django</code>自己的模块来处理，这里没怎么看(o′┏▽┓｀o) </p></li></ul><p>嘛，总觉得django这样帮我把默认名字起好了有点点难受，还要专门去记它存放的路径到底要是什么格式，要是出了问题的话，还是看报错信息快一点吧（狗头）</p><h4 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h4><p>主要参考<a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Models">MDN教程第三部分</a>和<a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Generic_views">第六部分</a>这部分可以结合前面说的<code>ListView</code>和<code>DetailView</code>来看看</p><p>如果你现在不是在对一个模块进行操作（而不是像上面说的<code>include(&#39;catalog.urls&#39;)</code>那样），那么请把<code>models.py</code>丢在和<code>settings.py</code>同级的目录里；如果是对一个模块进行操作，那么修改你执行<code>python manage.py startapp yourappname</code>的时候自动帮你创建出来的<code>models.py</code>就好了</p><p>举个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInstance</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Model representing a specific copy of a book (i.e. that can be borrowed from the library).&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">id</span> = models.UUIDField(primary_key=<span class="literal">True</span>, default=uuid.uuid4,</span><br><span class="line">                          help_text=<span class="string">&#x27;Unique ID for this particular book across whole library&#x27;</span>)</span><br><span class="line">    book = models.ForeignKey(<span class="string">&#x27;Book&#x27;</span>, on_delete=models.PROTECT, null=<span class="literal">True</span>)</span><br><span class="line">    imprint = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    due_back = models.DateField(null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    LOAN_STATUS = (</span><br><span class="line">        (<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;Maintenance&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;On loan&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;Available&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;Reserved&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    status = models.CharField(</span><br><span class="line">        max_length=<span class="number">1</span>,</span><br><span class="line">        choices=LOAN_STATUS,</span><br><span class="line">        blank=<span class="literal">True</span>,</span><br><span class="line">        default=<span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">        help_text=<span class="string">&#x27;Book availability&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    borrower = models.ForeignKey(User,on_delete=models.SET_NULL,null=<span class="literal">True</span>,blank=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">&#x27;due_back&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;String for representing the Model object.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span> (<span class="subst">&#123;self.book.title&#125;</span>)&#x27;</span></span><br></pre></td></tr></table></figure><p>我们要新建一个<code>model</code>，需要继承自<code>django.db.models.Model</code></p><p>其中的<code>book</code>、<code>due_back</code>之类的就是数据表里面的属性值，可以定义这个属性的取值类型和范围，如果是可选域（类似于上述<code>LOAN_STATUS</code>），就用元组来表示可选的范围</p><p><code>class Meta</code>可以定义在数据库中默认如何进行排序</p><p>而<code>def __str__(self)</code>则定义了当我们输出数据库中某个项时的信息，值得注意的是<code>def get_absolute_url</code>方法我们最好也写一下，这样可以在<code>template</code>中通过<code>元组.get_absolute_url</code>方法拿到对应的路径，用来访问单个元素的详细信息</p><p>一个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_absolute_url</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns the url to access a detail record for this book.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> reverse(<span class="string">&#x27;book-detail&#x27;</span>, args=[<span class="built_in">str</span>(self.<span class="built_in">id</span>)])</span><br></pre></td></tr></table></figure><p>在上面这个例子中，我们需要在路径中加上关于<code>path(&#39;book-detail/&lt;int:pk&gt;,views.xxxView,name=&#39;xxx&#39;)</code>的映射关系，然后类似前述的操作，添加继承了<code>DetailView</code>的类和相应的html文件用来展示该元素的详细信息</p><p><strong>注意</strong>：定义好了<code>model</code>之后，需要在<code>manage.py</code>的同级目录下执行<code>python manage.py makemigrations</code>和<code>python manage.py migrate</code>两个命令，才能将这些model添加到数据库中，之后每一次对model进行修改都要记得执行这两个命令</p><h4 id="view-py"><a href="#view-py" class="headerlink" title="view.py"></a>view.py</h4><p>呐呐呐，定义了<code>model</code>，那要咋用才能把数据库里的东西展示到页面上嘞</p><p><code>view.py</code>里面，除了像之前说的<code>class AuthorListView(generic.ListView)</code>的方式之外，还可以有别的方式来读取数据库中的信息</p><p>一个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;View function for home page of site.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate counts of some of the main objects</span></span><br><span class="line">    num_books = Book.objects.<span class="built_in">all</span>().count()</span><br><span class="line">    num_instances = BookInstance.objects.<span class="built_in">all</span>().count()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Available books (status = &#x27;a&#x27;)</span></span><br><span class="line">    num_instances_available = BookInstance.objects.<span class="built_in">filter</span>(status__exact=<span class="string">&#x27;a&#x27;</span>).count()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The &#x27;all()&#x27; is implied by default.</span></span><br><span class="line">    num_authors = Author.objects.count()</span><br><span class="line"></span><br><span class="line">    num_genres = Genre.objects.count()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Number of visits to this view, as counted in the session variable.</span></span><br><span class="line">    num_visits = request.session.get(<span class="string">&#x27;num_visits&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    request.session[<span class="string">&#x27;num_visits&#x27;</span>] = num_visits + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&#x27;num_books&#x27;</span>: num_books,</span><br><span class="line">        <span class="string">&#x27;num_instances&#x27;</span>: num_instances,</span><br><span class="line">        <span class="string">&#x27;num_instances_available&#x27;</span>: num_instances_available,</span><br><span class="line">        <span class="string">&#x27;num_authors&#x27;</span>: num_authors,</span><br><span class="line">        <span class="string">&#x27;num_genres&#x27;</span>: num_genres,</span><br><span class="line">        <span class="string">&#x27;num_visits&#x27;</span>: num_visits</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Render the HTML template index.html with the data in the context variable</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>, context=context)</span><br></pre></td></tr></table></figure><p>其中<code>Book</code>、<code>BookInstance</code>等是我们在<code>models.py</code>里事先定义好了的<code>model</code>，可以通过<code>MYMODEL.objects.all().count()</code>获取总共有多少数据项，或者通过<code>MYMODEL.objects.filter(xxx).count()</code>来获取有多少符合条件的数据项</p><p>可以注意到，这个函数的输入参数叫<code>request</code>，可以从中拿到<code>session</code>的信息，<code>request.session.get(&#39;num_visits&#39;,1)</code>表示，如果没有<code>num_visits</code>这个域，就创建它并将初始值设为1</p><p>在这个函数中的变量，可以通过全部封装到<code>context</code>字典中，作为参数传给<code>render</code>方法，这样就可以在<code>template</code>中通过名字使用这些变量了</p><p>对于上面这个函数，在<code>urls.py</code>中的映射为<code>path(&#39;index/&#39;,views.index,name=&#39;index&#39;)</code></p><h4 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h4><p>Django是支持模板继承的</p><p>一个可以被继承的模板大概长这个样子<code>base_generic.html</code>，它被放在该模块的<code>template</code>文件夹下（和<code>xxx_detail.html</code>不同，<code>xxx_detail.html</code>文件还要再往里放进去一层）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  &#123;% block title %&#125;<span class="tag">&lt;<span class="name">title</span>&gt;</span>Local Library<span class="tag">&lt;/<span class="name">title</span>&gt;</span>&#123;% endblock %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Add additional CSS in static file --&gt;</span></span><br><span class="line">  &#123;% load static %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;css/styles.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-2&quot;</span>&gt;</span></span><br><span class="line">      &#123;% block sidebar %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-nav&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;index&#x27; %&#125;&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>All books<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>All authors<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">     &#123;% endblock %&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-10 &quot;</span>&gt;</span>&#123;% block content %&#125;&#123;% endblock %&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>&#123;% block&#125;</code>标记的地方是可以在继承后中间添加东西的，不然使用的就是默认的内容</p><p>下面是一个继承了该模板的栗子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base_generic.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Local Library Home<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome to LocalLibrary, a website developed by <span class="tag">&lt;<span class="name">em</span>&gt;</span>Mozilla Developer Network<span class="tag">&lt;/<span class="name">em</span>&gt;</span>!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dynamic content<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The library has the following record counts:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Books:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123;&#123; num_books &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Copies:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123;&#123; num_instances &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Copies available:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123;&#123; num_instances_available &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Authors:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123;&#123; num_authors &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>这里我们改写了<code>&#123;% block content%&#125;`部分的内容**注意**：+ 要先指明继承的哪个模板：`&#123;% extends "base_generic.html" %&#125;`+ 写了`&#123;% block content %&#125;`后面记得接上`&#123;% endblock %&#125;</code></p><p>好家伙，看到我们刚刚在<code>def index(request)</code>里面写的变量名了吗，这里可以直接使用<code>&#123;&#123; variable_name &#125;&#125;</code>来使用它们，如果传进来的变量是个对象，我们甚至还可以用<code>variable.xxx</code>来访问它的属性值</p><p>具体的模板<code>if</code>/<code>for</code>语法等请自行查阅资料</p><hr/><p>嘛，知道了这几个部分之后，至少可以写出来一些简单的页面和跳转了吧</p><p>遇事不决请查看<a href="https://docs.djangoproject.com/en/3.2/contents/">官方文档</a> or <a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django">MDN</a></p><p>Django还有一些关于用户认证、<code>admin.py</code>、form表单和提供给用户操作数据库页面的内容，之后有时间再写吧</p><p>好（wo）想（shi）摸（fei）鱼（wu）.jpg</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>明日方舟 如何抠出小人透明背景GIF</title>
      <link href="p/574c2142.html"/>
      <url>p/574c2142.html</url>
      
        <content type="html"><![CDATA[<p>事情的起因是看到b站上有人把方舟的小人弄了下来然后放到了桌面当看板娘(:３っ)∋ </p><p>搞了半天不知道怎么就遍历到了把prts上小人的gif弄下来（可能为了以后整活做准备吧）</p><p><a href="https://www.bilibili.com/video/BV137411F76f">参考视频</a></p><p>视频里面是旧版的prts，主要是要f12把整个页面的背景弄成绿色，然后用录屏软件录个屏，然后用ae把背景去掉就好了</p><p>但是新版的prts已经可以直接下载gif了，甚至还可以调小人动画的的背景色还有透明度，现在直接把背景调到透明然后点下载就好了</p><p>但是整活大师瓜某眼瞎，刚开始只看到了调背景颜色没看到透明度，还是经历了一下ae扣背景图+pr导出gif的痛苦流程，但是以后可能会用得着，这里先记着吧</p><p>这里拿我们可爱的温蒂来举栗子</p><h3 id="Step1-下载纯色背景的gif"><a href="#Step1-下载纯色背景的gif" class="headerlink" title="Step1:下载纯色背景的gif"></a>Step1:下载纯色背景的gif</h3><p>最好是绿的绿的绿的，绿幕抠像背景一般都是绿的不然就是蓝的，把rgb调成(0,255,0)就好了</p><p>新版的prts选好gif背景色皮肤模型动画然后点下载</p><img src="/img/image-20210313233158818.png" alt="image-20210313233158818" style="zoom: 67%;" /><p>可能prts上是真的用骨架模型+组件临时生成的，有些皮肤可能会贼慢，需要等一等</p><img src="/img/image-20210313233337652.png" alt="image-20210313233337652" style="zoom: 67%;" /><h3 id="Step2-ae导出透明背景图片序列"><a href="#Step2-ae导出透明背景图片序列" class="headerlink" title="Step2:ae导出透明背景图片序列"></a>Step2:ae导出透明背景图片序列</h3><p>把刚刚下载的gif导入项目，再把它拖到中间“新建合成”的位置</p><p>在右边的“效果和预设”里面搜索<code>keylight</code>，那个<code>Keylight(1,2)</code>就是我们要的东西，把它拖到中间的图像上</p><p><img src="/img/image-20210313233659456.png" alt="image-20210313233659456"></p><p><img src="/img/image-20210313233949174.png" alt="image-20210313233949174"></p><p>这个时候左边会出现控制这个效果的面板，点<code>Screen Colour</code>选项的那个吸管，然后点一下显示图片里面的绿色，<code>Screen Colour</code>就会变成下图这样</p><p><img src="/img/image-20210313234123503.png" alt="image-20210313234123503"></p><p>如果你的图片在吸管吸过之后背景没有变透明，而是变成了全黑（类似下图这样）</p><img src="/img/image-20210313234236424.png" alt="image-20210313234236424" style="zoom:50%;" /><p>不要慌张，只是没有切换透明网格而已，点一下下面<code>切换透明网格</code>的按钮就好了</p><p><img src="/img/image-20210313234354996.png" alt="image-20210313234354996"></p><img src="/img/image-20210313234607169.png" alt="image-20210313234607169" style="zoom:50%;" /><p>于是这个时候，我们得到了一个透明背景的温蒂，但是ae没有办法导出gif，所以要先导成透明背景的png序列，然后到ps里面处理</p><p><code>Ctrl+M</code>把它放到渲染队列里面，点击<code>输出模块</code>里的<code>无损</code></p><p><img src="/img/image-20210313234722919.png" alt="image-20210313234722919"></p><p>把通道选为<code>RGB+Alpha</code>，格式选为<code>png序列</code></p><img src="/img/image-20210313234753896.png" alt="image-20210313234753896" style="zoom:67%;" /><p>填好了输出的路径之后，点渲染就可以了</p><p>渲染完之后，我们获得了一个和这个gif同名的文件夹</p><p><img src="/img/image-20210313235015543.png" alt="image-20210313235015543"></p><p>点开之后里面全是一帧一帧的温蒂</p><img src="/img/image-20210313235052492.png" alt="image-20210313235052492" style="zoom:80%;" /><h3 id="Step3-ps生成透明背景的gif"><a href="#Step3-ps生成透明背景的gif" class="headerlink" title="Step3:ps生成透明背景的gif"></a>Step3:ps生成透明背景的gif</h3><p>打开ps，<code>Ctrl+O</code>打开刚刚生成的图像序列的第一张，选中下面的<code>图像序列</code>选项</p><p><img src="/img/image-20210314002756355.png" alt="image-20210314002756355"></p><p>在跳出来的设置里面选择自己希望的帧速率，点击确定之后可以点下面序列的播放按钮查看效果</p><p>点击<code>文件</code>-&gt;<code>存储为Web所用格式</code></p><p><img src="/img/image-20210314003600098.png" alt="image-20210314003600098"></p><p>确保透明度勾上了，选择的是图案透明度仿色之后，点击存储，就可以康到透明背景的可爱温蒂啦</p><p><img src="/img/image-20210314003821526.png" alt="image-20210314003821526"></p><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul><li>prts上选择透明之后不知道为啥我下载下来的背景图就是全黑的而不是透明的</li><li>某一些动作比较多的动作（比如说上面这个温蒂的基建特效动作）prts上生成这个gif需要等的时间比较长，而且在ae里面打开动作会非常的慢，如果导出的时候不希望有太多张图片的话（上面这个栗子原本没调速度的话有300+图片），可以在导出的设置里面把帧数调低一点（这里压到了100+，ae帧率调成了15），还可以在ps里面调帧速来还原原来的速度（这里ps帧率为30fps）</li></ul><h3 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h3><p>封面是deco的新歌ヴァンパイア，MV的绘还有歌都太棒太棒啦</p><p><a href="https://www.bilibili.com/video/BV1by4y187EM?from=search&seid=16931544522925978996">私心的B站链接 DECO*27 - ヴァンパイア feat. 初音ミク</a></p><p>最后附上辛苦扣出来的可爱温蒂</p><p><img src="/img/weddy.gif" alt="温蒂"></p>]]></content>
      
      
      <categories>
          
          <category> 摸鱼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 明日方舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Jupyterhub Authenticator的使用</title>
      <link href="p/9cf05e84.html"/>
      <url>p/9cf05e84.html</url>
      
        <content type="html"><![CDATA[<p>前面提到了Hub的一个重要作用：对登录的用户进行身份认证，那俺们来详细讲讲这个<code>Authenticator</code>是怎么用的</p><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">阮一峰：OAuth2.0的四种方式</a></p><p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">阮一峰：JSON Web Token 入门教程</a></p><p><a href="https://www.loginradius.com/blog/async/using-jwt-with-oauth2-when-and-why/">How to Use JWT with OAuth</a></p><h3 id="LoginHandler处理逻辑"><a href="#LoginHandler处理逻辑" class="headerlink" title="LoginHandler处理逻辑"></a>LoginHandler处理逻辑</h3><p>默认的<code>login_url</code>是<code>/hub/login</code>，当我们在浏览器窗口输入<code>localhost:8000</code>时，会由<code>RootHandler</code>进行处理，如果它发现找不到当前用户的话，就会跳转到<code>login_url</code>的位置，也就需要<code>LoginHandler</code>进行处理，也就是登录认证</p><img src="/img/image-20210308162027033.png" alt="image-20210308162027033" style="zoom:80%;" /><p>跳转到<code>/hub/login</code>之后，对应的是<code>LoginHandler</code>的<code>get</code>方法的处理逻辑，有两种处理方式：</p><ul><li><p>如果没有设置<code>authenticator.auto_login</code>，就会渲染出需要输入用户名和密码的页面</p><p>当输入了用户名和密码并确认之后，会调用<code>LoginHandler</code>的<code>POST</code>方法，将对应的<code>data</code>作为参数发送给<code>login_user</code>方法，而<code>login_user</code>方法再把这些<code>data</code>作为参数传给我们使用的<code>Authenticator</code>的<code>authenticate</code>方法</p><p>如果认证成功，则会返回用户的信息，否则返回为空，认证成功的用户会跳转到对应的页面去</p></li><li><p>如果设置了<code>authenticator.auto_login</code></p><ul><li>我们设置的<code>auto_login_url</code>和默认的<code>login_url</code>相等的话，会调用<code>login_user</code>方法，然后调用我们实现的<code>authenticator</code>的<code>authenticate</code>方法来实现对应的处理逻辑（用来认证的信息已经在<code>request</code>里面了）</li><li>如果不相等，则会跳转到我们设置的<code>auto_login_url</code>的位置进行处理（后面会讲到的OAuth2使用的就是这种方式，对应的<code>authenticator</code>的<code>login_url</code>已经在<code>jupyterhub_config.py</code>文件中设置了）</li></ul></li></ul><img src="/img/image-20210308163241400.png" alt="image-20210308163241400" style="zoom:80%;" /><h3 id="PAMAuthenticator"><a href="#PAMAuthenticator" class="headerlink" title="PAMAuthenticator"></a>PAMAuthenticator</h3><p>JupyterHub默认使用的<code>Authenticator</code>是<code>PAMAuthenticator</code>，可以在<code>auth.py</code>里面找到它</p><p><code>PAMAuthenticator</code>使用的是<code>pamela</code>模块来进行认证</p><img src="/img/image-20210308163837826.png" alt="image-20210308163837826" style="zoom:80%;" /><blockquote><p>PAM（Pluggable Authentication Modules ）是由Sun提出的一种认证机制。它通过提供一些动态链接库和一套统一的API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段</p></blockquote><p><code>Pamela</code>是PAM的一个python wrapper</p><h3 id="OAuth2和JWT"><a href="#OAuth2和JWT" class="headerlink" title="OAuth2和JWT"></a>OAuth2和JWT</h3><h4 id="什么是OAuth2"><a href="#什么是OAuth2" class="headerlink" title="什么是OAuth2"></a>什么是OAuth2</h4><p>如果当前我有一个应用A，它想要获得我的谷歌账号中的图片信息，但出于安全考虑，我又不能直接把我的谷歌账号密码给他，让他直接登录我的谷歌账号下载图片。于是我就要在这个应用和谷歌之间设置一个授权层，让应用A只能登录到授权层去获取开放的资料，对于不在授权层范围内的东西，它就接触不到</p><p>而OAuth就实现了在应用和服务提供商之间，设置了这样一个授权层。该应用登录到授权层使用的令牌和我登录谷歌使用的密码不同，且是有权限范围和有效期的</p><p><strong>重点</strong>：客户端（应用）必须得到用户的授权（authorization grant）之后才能获得令牌（access token），然后通过令牌去登录到授权层访问需要的东西</p><h4 id="OAuth2流程"><a href="#OAuth2流程" class="headerlink" title="OAuth2流程"></a>OAuth2流程</h4><p>OAuth2共有四种访问模式，这里只讲授权码（Authorization Code）模式（其他的感觉都是它的简化版）</p><p>OAuth2的运行流程一共有六个步骤：</p><ul><li>用户打开客户端，客户端要求用户予以授权（客户端跳转到登录/认证页面）</li><li>用户同意对客户端进行授权（用户在跳转的页面输入用户名密码等信息，点击确认，获得<code>AUTHORIZATION_CODE</code>（之类的））</li><li>客户端使用上一步获得的授权，向认证服务器申请令牌（access_token）</li><li>认证服务器对客户端进行认证后，确认无误，发放令牌</li><li>客户端使用令牌，向资源服务器申请获取资源</li><li>服务器确认令牌无误，同意开放资源</li></ul><p>好家伙，上面一通乱讲完全听不懂</p><p>那我们来看个栗子</p><p>前面提到，如果我在<code>jupyterhub_config.py</code>文件里面设置了自己的<code>login_url</code>，那么<code>LoginHandler</code>就会跳转到对应的处理逻辑</p><p>这里假设我们在<code>jupyterhub_config.py</code>文件中设置的<code>login_url</code>为<code>myoauth_login</code>，并在初始化的时候为我们的hub添加了一个关于处理<code>/myoauth_login</code>的<code>RequestHandler</code>的子类（我们叫他<code>MyOauthHandler</code>好了），那么输入<code>localhost:8000</code>的时候就会跳转到这个<code>MyOauthHandler</code>的<code>get</code>方法来进行处理</p><p>对着上面六个步骤依葫芦画瓢：</p><h5 id="step1-amp-2"><a href="#step1-amp-2" class="headerlink" title="step1&amp;2"></a>step1&amp;2</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyOauthHandler</span></span><br><span class="line"><span class="comment"># 第1&amp;2步，客户端让用户跳转到登录页面进行授权，用户同意授权</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">    redirect_url = self.authenticator.get_callback_url(self)</span><br><span class="line">    ...</span><br><span class="line">    self.authorize_redirect(</span><br><span class="line">    redirect_url = redirect_url,</span><br><span class="line">        client_id = client_id,</span><br><span class="line">        scope = self.authenticator.scope,</span><br><span class="line">        response_type = code</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>讲讲这些参数是干啥用的：</p><ul><li><code>redirect_url</code>：用户登录之后点击了确认，认证服务器总要把授权码返回吧，那我的认证服务器知道要返回到哪个url就要靠这个<code>redirect_url</code></li><li><code>client_id</code>：告诉认证服务器是谁在请求</li><li><code>scope</code>：要求授权的范围是啥</li><li><code>response_type</code>：要求返回的是啥，如果<code>response_type</code>为<code>code</code>，则要求返回授权码（四种访问模式要求的<code>response_type</code>是不一样的）</li><li>还可以加入一些额外的参数，比如<code>extra_params</code>之类的</li></ul><p>关于<code>scope</code>、<code>callback_url</code>等，都可以在<code>jupyterhub_config.py</code>文件中进行设置</p><h5 id="step3-amp-4"><a href="#step3-amp-4" class="headerlink" title="step3&amp;4"></a>step3&amp;4</h5><p>当用户授权完毕后，认证服务器会跳转到我们设置的<code>redirect_url</code>的位置，因此我们需要事先为它设置相应的<code>RerequestHandler</code>的子类来进行处理</p><p>假设我们设置的<code>redirec_url</code>为<code>myoauth_callback</code>，对应的<code>RequestHandler</code>子类为<code>MyCallbackHandler</code>，那么我们就可以在<code>get()</code>方法中拿到认证服务器返回给我们的<code>AUTHORIZATION_CODE</code></p><p>一个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyCallbackHandler</span></span><br><span class="line"><span class="comment"># 第3&amp;4步，客户端使用上一步获得的授权码，向认证服务器申请令牌，认证服务器认证无误后发放令牌</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_code</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.get_argument(<span class="string">&quot;code&quot;</span>,<span class="literal">False</span>):</span><br><span class="line">        <span class="keyword">raise</span> web.HTTPError(...)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_user</span>():</span></span><br><span class="line">params = <span class="built_in">dict</span>(</span><br><span class="line">    redirect_uri = self.get_callback_url(handler)</span><br><span class="line">        code = code,</span><br><span class="line">        grant_type = <span class="string">&#x27;authorization_code&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    // ...</span><br><span class="line">    token_resp_json = <span class="keyword">await</span> self._get_token(...,params)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    self.check_code()</span><br><span class="line">    // ...</span><br><span class="line">    self.login_user()</span><br></pre></td></tr></table></figure><p><img src="/img/image-20210308234648714.png" alt="image-20210308234648714"></p><p>从上面这张图里，可以看出服务器返回的数据中有我们要的<code>code</code>的信息，然后我们调用<code>login_user()</code>方法，拿着授权码去找认证服务器要令牌</p><p>再来讲讲里面的参数：</p><ul><li><code>client_id</code>：用来让认证服务器确认客户端的身份</li><li><code>client_secret</code>：用来加密</li><li><code>grant_type</code>：说明授权方式（这里写的<code>authorization_code</code>表示是授权码方式）</li><li><code>code</code>：上一步拿到的授权码</li><li><code>redirect_url</code>：拿到了令牌后认证服务器的回调地址</li></ul><p>好家伙，当<code>self._get_token()</code>执行完的之后，我们就可以在<code>token_resp_json</code>里面拿到我们要用的令牌了（<code>access_token</code>字段）</p><h5 id="step5-amp-6"><a href="#step5-amp-6" class="headerlink" title="step5&amp;6"></a>step5&amp;6</h5><p>我们可以在<code>login_user()</code>方法里面继续往下写拿到了令牌之后的操作，去找服务器要用户数据（这个时候已经有令牌了，nice）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_user</span>():</span></span><br><span class="line">params = <span class="built_in">dict</span>(</span><br><span class="line">    redirect_uri = self.get_callback_url(handler)</span><br><span class="line">        code = code,</span><br><span class="line">        grant_type = <span class="string">&#x27;authorization_code&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    // ...</span><br><span class="line">    token_resp_json = <span class="keyword">await</span> self._get_token(...,params)</span><br><span class="line">    user_data_resp_json = <span class="keyword">await</span> self._get_user_data(...,token_resp_json)</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><p>这里我们把上一步拿到的令牌作为参数传给了<code>_get_user_data()</code>方法，它就可以取出里面的令牌去找服务器要数据啦</p><p>（OAuth2流程大概就长这样）</p><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><blockquote><p>JWT，即JSON Web Token，是目前最流行的跨域认证解决方案，常用于无状态身份认证</p></blockquote><p>JWT的基本原理是，服务器不保存session数据（这样服务器就变成无状态的了），将所有的数据都保存在客户端，在服务器认证后生成一个JSON对象，用户之后每一次和服务器通信都会把这个JSON对象发送给服务器，服务器靠它来认证用户的身份</p><p>但是为了防止用户篡改数据，服务器生成这个JSON对象的时候，会加上签名（后面将JWT结构会讲到）</p><p>JWT主要由三部分组成：</p><ul><li><code>Header</code>：元数据，签名的算法、token类型等</li><li><code>Payload</code>：实际要传送的数据</li><li><code>Signature</code>：对前两部分的签名，需要一个secret，使用header中指定的签名算法产生签名</li></ul><p>之后客户端和服务器每次通信都带上这个JWT，把它放在Authorization字段里面</p><h5 id="Using-JWT-with-OAuth2"><a href="#Using-JWT-with-OAuth2" class="headerlink" title="Using JWT with OAuth2"></a>Using JWT with OAuth2</h5><p>因为OAuth2的协议中并没有指定令牌的格式，因此可以将JWT应用到OAuth2中</p><p>从OAuth2认证服务器返回回来的access_token可以是JWT的格式，且可以通过payload携带额外的信息</p>]]></content>
      
      
      <categories>
          
          <category> JupyterHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JupyterHub </tag>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git内部原理-笔记</title>
      <link href="p/605bc8be.html"/>
      <url>p/605bc8be.html</url>
      
        <content type="html"><![CDATA[<p>看了之后总觉得之前操作系统实验不是白写的╰(￣ω￣ｏ)</p><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html">阮一峰:Git原理入门</a></p><p><a href="https://segmentfault.com/a/1190000016320008">Git数据存储的原理浅析</a></p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1">Git内部原理－Git对象</a></p><p><code>.git</code>目录是维护git信息的目录</p><h2 id="git文件结构"><a href="#git文件结构" class="headerlink" title="git文件结构"></a>git文件结构</h2><p><code>.git</code>文件中的内容</p><p><img src="/img/clip_image002.png" alt="img"></p><ul><li><p>HEAD</p><p>当前提交的指针的位置</p><p><img src="/img/clip_image004.png" alt="img"></p></li><li><p>refs/head</p><p>保存了本地全部分支最后一次提交的id</p><p>由于每一次commit的实际上是commit一个文件，而这个id就是commit文件的hash值，这种方式贯穿了git的全部文件的命名</p><p><img src="/img/clip_image005.png" alt="img"></p></li><li><p>log</p><p>每一次提交的记录</p><p><img src="/img/clip_image007.png" alt="img"></p></li><li><p>objects</p><p>存放git本地仓库对象</p></li></ul><h2 id="Git底层数据对象"><a href="#Git底层数据对象" class="headerlink" title="Git底层数据对象"></a>Git底层数据对象</h2><p><img src="/img/clip_image009.png" alt="img"></p><ul><li><p>tag对象</p></li><li><p>blob对象</p><p>用于存储文件内容（不会保存文件名）</p><p>因为<code>git add .</code>命令实际上执行的是</p><ul><li>保存对象（<code>git hash-object</code>）</li><li>更新暂存区（<code>git update-index</code>，在暂存区记录一个发生变动的文件）</li></ul><p>其中<code>git hash-object</code>做的就是就是把文件的内容压缩为二进制文件，称为一个git对象（文件的话就是blob对象），保存在<code>.git/objects</code>目录中</p><p>使用<code>git hash-obejct</code>命令还会计算当前内容的<code>SHA1</code>哈希值（长度为40的字符串），作为该对象的文件名，其中前两个字母为object文件夹中的文件夹名，后面的字母为该文件夹下的文件名，如果用<code>cat</code>查看的话会发现里面是一些压缩后的二进制内容</p><p><img src="/img/clip_image011.png" alt="img"></p></li><li><p>tree对象</p><p>用于存储当前目录结构，能够保存文件名，将多个文件组织到一起</p><p><code>git write-tree</code>命令能够将当前的目录结构生成一个git对象（tree对象），也保存在<code>.git/object</code>目录中</p></li><li><p>commit对象</p><p><code>commit</code>的时候有提交说明，包括所在的tree，parent（父提交）是谁，作者等信息</p><p><code>git commit-tree</code>命令将元数据（blob）和目录树（tree）一起生成一个git对象（commit对象），也保存在<code>git/object</code>目录中</p><p>这样通过上面那张图，就可以大致看出git本地存储的文件结构了</p></li></ul><p>在每一次提交的时候，objects、logs以及refs文件夹都会发生变化：</p><ul><li>objects文件夹中新增对应的tree、blob以及commit对象（通过SHA-1对内容和头信息生成Hash值）</li><li>logs文件夹中对应分支的文件新增一次提交记录</li><li>更改refs文件夹中对应分支最新一次提交的id（commit对象的值）</li></ul><h2 id="剖析Git对象"><a href="#剖析Git对象" class="headerlink" title="剖析Git对象"></a>剖析Git对象</h2><p>由于<code>.git/objects</code>目录中的文件都是压缩过的，可以使用<code>cat-file</code>命令从git中取回数据（剖析git对象），<code>-p</code>选项可以使该命令自动判断内容的类型，并展示大致内容</p><p>如果删掉了本地的副本，而<code>.git/objects</code>中还保存着压缩后的内容，在知道对应的SHA-1的情况下，可以取回对应的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span><br></pre></td></tr></table></figure><h2 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h2><p>由于Git最初向磁盘中存储对象所使用的格式为loose格式，它会时不时将多个这些对象打包成一个packfile的二进制文件，用来节省空间和提升效率（垃圾回收，手动方式：<code>git gc --auto</code>，可以通过<code>gc.auto</code>和<code>gc.autopacklimit</code>来设置超过多少个松散对象和包文件才让git启动一次gc命令）</p><p>可以使用<code>git gc</code>命令对Git对象进行打包；向远程服务器进行推送时，git也会打包</p><p>打包之后，你的<code>objects</code>目录可能变成这个样子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">.git/objects/info/packs</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</span><br></pre></td></tr></table></figure><p><code>pack</code>是一个包文件，而<code>idx</code>是对应的索引文件</p><p>索引文件中包含了包文件的偏移信息，可以通过索引文件快速定位任意一个指定对象</p><p>git打包对象时，会查找命名及大小相近的文件，且保存不同文件版本之间的差异</p><p>如果执行了<code>git gc</code>命令，该命令还会将<code>refs</code>文件夹中的文件进行打包，将其移动到名为<code>.git/packed-refs</code>的文件中，因此，如果你在<code>refs</code>目录中找不到一个引用，那么它可能在<code>packed-refs</code>文件中 </p><p>那么那么那么，学习了上面的知识，如果不采用传送整个<code>.git</code>文件夹的方式，每次要把本地<code>commit</code>的文件传送到远端，我们需要发送哪些文件嘞(σ｀д′)σ</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摸鱼合集</title>
      <link href="p/bde6ec7d.html"/>
      <url>p/bde6ec7d.html</url>
      
        <content type="html"><![CDATA[<p>瓜瓜的不定期摸鱼合集</p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=673981977&bvid=BV1FU4y137Tq&cid=363279476&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=248579891&bvid=BV1ev411p7xg&cid=350619847&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=930983792&bvid=BV1kK4y1X7NV&cid=349753433&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=333290385&bvid=BV1fA411g7JZ&cid=344903827&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=673296525&bvid=BV1YU4y1L7tj&cid=344020900&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=845548525&bvid=BV1N54y1L7GQ&cid=337676713&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=333052268&bvid=BV1jA411G7k8&cid=337221707&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=757954664&bvid=BV1J64y127NV&cid=335938705&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=375006348&bvid=BV1YZ4y1c7Uk&cid=324694127&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=844544971&bvid=BV1x54y1a7kC&cid=307324801&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=204442921&bvid=BV12h411k7N9&cid=305192999&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr>]]></content>
      
      
      <categories>
          
          <category> 摸鱼 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件权限</title>
      <link href="p/1915f42e.html"/>
      <url>p/1915f42e.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://cn.linux.vbird.org/">鸟哥的Linux私房菜</a>看着有点意思</p><p>因为之前配环境装东西的时候因为文件的权限问题搞了好久，看了鸟哥的书之后整理一下</p><h2 id="1-用户和用户组"><a href="#1-用户和用户组" class="headerlink" title="1.用户和用户组"></a>1.用户和用户组</h2><p>因为Linux是个多人多任务的系统，所以对文件权限的管理就非常的重要</p><p>用户和用户组可以解决：</p><ul><li>只属于自己的文件不想给别人看</li><li>同一组的文件只能在组内共享，别人看不了</li></ul><p>的问题</p><p>这里有三个概念：</p><ul><li>用户（User）</li><li>用户组（Group）</li><li>其他人（Other）</li></ul><p>Linux中任何一个文件都有这三种身份的权限</p><p>举一个栗子，用户相当于akane，用户组相当于akane家，akane的兄弟姐妹也是不同的用户，而akane和ta的兄弟姐妹就组成了一个用户组。akane的小金库不想和兄弟姐妹共享，那么这个小金库就只对akane开放，对于akane所在的用户组中的其他用户都是不开放的；而不属于akane所在组的用户就属于others，akane的小金库对他们也是不开放的；而akane家的冰箱对于akane和ta的兄弟姐妹都是开放的，大家可以自己拿自己想吃的东西，但是对于others是不开放的（比如说他们不希望别人随便来他们家冰箱找吃的）</p><p>但是全能的神可以不管akane或者ta的兄弟姐妹想不想把东西给他看，对世间万物（?）都可以随便拿随便看，在Linux中这个全能的神就是root</p><p>Linux的文件权限差不多就类似于上面栗子的玩意</p><h2 id="2-Linux文件属性"><a href="#2-Linux文件属性" class="headerlink" title="2.Linux文件属性"></a>2.Linux文件属性</h2><p>在terminal使用命令<code>su -</code>切换到<code>root</code>身份后，输入命令<code>ls -al</code>，可以看到类似于下面的Linux文件的详细信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls -al</span><br><span class="line">total 156</span><br><span class="line">drwxr-x---   4    root   root     4096   Sep  8 14:06 .</span><br><span class="line">drwxr-xr-x  23    root   root     4096   Sep  8 14:21 ..</span><br><span class="line">-rw-------   1    root   root     1474   Sep  4 18:27 anaconda-ks.cfg</span><br><span class="line">-rw-------   1    root   root      199   Sep  8 17:14 .bash<span class="emphasis">_history</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root       24   Jan  6  2007 .bash_</span>logout</span><br><span class="line">-rw-r--r--   1    root   root      191   Jan  6  2007 .bash<span class="emphasis">_profile</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root      176   Jan  6  2007 .bashrc</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root      100   Jan  6  2007 .cshrc</span></span><br><span class="line"><span class="emphasis">drwx------   3    root   root     4096   Sep  5 10:37 .gconf      </span></span><br><span class="line"><span class="emphasis">drwx------   2    root   root     4096   Sep  5 14:09 .gconfd</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root    42304   Sep  4 18:26 install.log &lt;=范例说明处</span></span><br><span class="line"><span class="emphasis">-rw-r--r--   1    root   root     5661   Sep  4 18:25 install.log.syslog</span></span><br><span class="line"><span class="emphasis">[<span class="string">    1   </span>][<span class="symbol">  2 </span>][<span class="string">   3  </span>][<span class="symbol">  4 </span>][<span class="string">    5   </span>][<span class="symbol">     6     </span>][<span class="string">       7          </span>]</span></span><br><span class="line"><span class="emphasis">[<span class="string">  权限  </span>][<span class="symbol">link</span>][<span class="string">user</span>][<span class="symbol">group</span>][<span class="string">文件容量</span>][<span class="symbol">  修改日期 </span>][<span class="string">      文件名        </span>]</span></span><br></pre></td></tr></table></figure><p>我们拿出第一个范例来看</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>对于范例处，也就是<code>-rw-r--r--</code>的内容</p><p>总共有十个字符，一般这样划分：<code>-/rw-/r--/r--</code></p><p>第一个字母表示的是该文件的类型，是文件还是文件夹还是链接文件等，这里介绍主要的几种</p><ul><li><code>d</code>：文件夹</li><li><code>-</code>：普通文件</li><li><code>l</code>：链接文件，也就是windows里面的快捷方式</li></ul><p>还有其他的文件类型，可以去看看鸟哥写的（懒狗发言）</p><p>之后的三个字符一组，分别表示的是：</p><ul><li>文件拥有者对文件的读、写、执行权限</li><li>文件所属用户组对文件的读、写、执行权限</li><li>其他人对该文件的读、写、执行权限</li></ul><p>在这个例子里：</p><ul><li>文件拥有者的读、写、执行权限为：<code>rw-</code></li><li>文件所属用户组对文件的读、写、执行权限为：<code>r--</code></li><li>其他人对该文件的读、写、执行权限为：<code>r--</code></li></ul><p>这三个字符是有固定位置的，分别为<code>rwx</code>，其中<code>r</code>表示可读，<code>w</code>表示可写，<code>x</code>表示可执行（对于文件和文件夹这三个字符的表示含义又有一些不同，之后会讲到）</p><p>如果没有对应的权限的话，该位置就会变成<code>-</code></p><p>例如，如果该用户对此文件有读和执行的权限，没有写的权限，则表示为<code>r-x</code></p><p>对于上面这个栗子，可以看出：</p><ul><li>文件拥有者对该文件可读可写（<code>rw-</code>）</li><li>文件所属用户组对该文件只可读（<code>r--</code>）</li><li>其他用户对该文件只可读（<code>r--</code>）</li></ul><p>举一个别的栗子，假设一个文件的权限部分写的是<code>drwxr-xr--</code>，我们可以做的事有：</p><ul><li>划分成<code>d/rwx/r-x/r--</code></li><li>第一个字符为<code>d</code>，说明这个文件是个文件夹</li><li>第一组三个字符为<code>rwx</code>，说明该文件所属的用户对该文件可读可写可执行</li><li>第二组三个字符为<code>r-x</code>，说明该文件所属用户组对该文件可读可执行</li><li>第三组三个字符为<code>r--</code>，说明其他用户对该文件只可读</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之后几栏分别表示什么呢</p><ul><li>十个字符后面的数字，也就是第二栏，表示的是链接数，说明有多少个文件名链接到这个结点</li><li>第三栏：该文件的拥有者账号</li><li>第四栏：该文件所属的用户组</li><li>第五栏：文件大小</li><li>第六栏：文件的创建日期或最近修改日期</li><li>第七栏：文件名</li></ul><h2 id="3-修改文件属性和权限"><a href="#3-修改文件属性和权限" class="headerlink" title="3.修改文件属性和权限"></a>3.修改文件属性和权限</h2><p><strong>警告</strong>：<code>chgrp</code>、<code>chown</code>和<code>chmod</code>只能在<code>root</code>下执行</p><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>即：change group，修改文件所属的用户组</p><p>一般格式：<code>chgrp [-R] groupname dirname/filename</code></p><p>其中<code>[-R]</code>表示进行递归的修改，用于修改目录所属用户组的时候，使其子目录和该目录下的文件也变成这个用户组的</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>即：change owner，修改文件所属用户</p><p>一般格式：<code>chown [-R] username dirname/filename</code></p><p>如果想同时修改文件所属的用户和用户组，也可以使用<code>chown</code>，格式为<code>chown [-R] username:groupname dirname/filename</code></p><p>也可以用<code>chown</code>来修改文件所属的用户组：<code>chown [-R] :groupname dirname/filename</code></p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>这个命令可以用来修改文件对于拥有者、所属用户组以及其他用户的读写执行权限</p><p>格式为：<code>chmod [-R] xyz dirname/filename</code></p><p>那么，<code>xyz</code>是什么呢</p><p>还记得之前三个三个分组的<code>rwx</code>吗，<code>r</code>表示4，<code>w</code>表示2，<code>x</code>表示1，对应用户/用户组/其他人拥有的权限对应的数字加起来得到的值，就是<code>chmod</code>命令中写的数字<code>xyz</code>了</p><p>举一个栗子，如果我们希望把一个文件的读写权限改成<code>rwx/r-x/r--</code>，那么对应的数字就是<code>754</code>，对应的命令就是<code>chmod 754 filename</code></p><p>如果写的命令是<code>chmod 777 filename</code>，就说明让这个文件对所有的用户可读可写可执行</p><h4 id="符号方式修改"><a href="#符号方式修改" class="headerlink" title="符号方式修改"></a>符号方式修改</h4><p>除了刚刚那种直接写数字的方法，还可以用符号来修改文件的权限</p><p>我们用<code>u</code>表示<code>user</code>，<code>g</code>表示<code>group</code>，<code>o</code>表示<code>other</code>，<code>a</code>表示全部</p><p><code>+</code>表示增加权限，<code>-</code>表示取消权限，<code>=</code>表示设置</p><p>希望看了下面的栗子能看出来它是怎么用的（狗头）</p><ul><li><p><code>chmod u=rwx,g=rw- filename</code>：文件拥有者权限设置为可读可写可执行，文件所属用户组权限设置为可读可写</p></li><li><p><code>chmod o-x filename</code>：去除其他用户对文件的可执行权限</p></li><li><p><code>chmod a+w filename</code>：为所有的用户加上对文件的可写权限</p></li></ul><h2 id="4-文件与目录的权限意义"><a href="#4-文件与目录的权限意义" class="headerlink" title="4.文件与目录的权限意义"></a>4.文件与目录的权限意义</h2><p>对文件：</p><ul><li><code>r</code>：可以读取文件内容</li><li><code>w</code>：可以编辑、修改、删除文件内容，但是<strong>不可以删除文件</strong></li><li><code>x</code>：该文件可以被系统执行</li></ul><p>对文件夹：</p><ul><li><code>r</code>：可以查询该目录下的文件名数据（但是如果没有<code>x</code>的话，就仅限于查看文件名）</li><li><code>w</code>：可以新建、删除、移动、重命名文件/文件夹</li><li><code>x</code>：<strong>可以进入这个文件夹作为你的工作目录</strong>，不然就只能在外面看看（如果这个文件夹对你来说没有<code>x</code>的话，你是<code>cd</code>不进去的）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Jupyterhub架构</title>
      <link href="p/4159f0cf.html"/>
      <url>p/4159f0cf.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于tornado"><a href="#关于tornado" class="headerlink" title="关于tornado"></a>关于tornado</h2><p>由于jupyterhub是非常典型的tornado应用结构，因此需要一些关于tornado的知识 <a href="https://tornado-zh.readthedocs.io/zh/latest/guide/structure.html">tornado官方文档链接</a></p><blockquote><p>A Tornado web application generally consists of one or more RequestHandler subclasses, an Application object with routes incoming requests to handlers, and a main() function to start the server</p></blockquote><p>一个tornado应用主要包括三部分：</p><ul><li>一个<code>Application</code>对象：用于全局配置，将请求的路由映射到对应的handler</li><li>多个<code>RequestHandler</code>子类：用于执行对应url的处理逻辑</li><li>一个启动服务的<code>main()</code>函数</li></ul><p><img src="/img/tornado.jpg" alt="tornado"></p><h3 id="Application对象"><a href="#Application对象" class="headerlink" title="Application对象"></a>Application对象</h3><p><code>Application</code>对象负责全局配置，将请求的路由映射到对应的handler，因此需要传递给<code>Application</code>一个路由表（<code>URLSpec</code> object list）用于进行路由的配置</p><p><a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings">官方Application configuration文档</a></p><h4 id="URLSpec"><a href="#URLSpec" class="headerlink" title="URLSpec"></a>URLSpec</h4><p>一个<code>URLSpec</code>的栗子：<code>url(r&quot;/story/([0-9]+)&quot;, StoryHandler, dict(db=db), name=&quot;story&quot;)</code></p><p>主要包含四个部分：**(matcher,** <strong>target,</strong> <strong>[target_kwargs],</strong> <strong>[name])</strong></p><ul><li>正则表达式（必写）：用于与url进行匹配，采用first matching rule</li><li>处理类（必写）：一个<code>RequestHandler</code>的子类，实现处理逻辑</li><li>dict（可选）：作为初始参数传给<code>RequestHandler.initialize()</code></li><li>name（可选）：允许其被<code>RequestHandler.reverse_url</code>使用</li></ul><p>对<code>Application</code>进行配置的时候不仅可以配置路由表，还可以配置其他的信息 </p><p>要添加额外的handlers，可以使用<code>application.add_handlers()</code>，添加额外的路由信息</p><h4 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h4><p>Settings主要用于自定义tornado的很多方面，这里只展示了部分，关于全部<code>settings</code>的内容请看<a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings">官方文档</a></p><ul><li>General settings</li><li>Authentication and security settings<ul><li><code>cookie_secret</code>：用于对cookies进行签名 <a href="https://blog.csdn.net/adley_app/article/details/80734247">cookie防篡改机制</a></li><li><code>login_url</code>：如果用户没有登录，<code>authenticated</code>装饰器将会重定向到这个url。可以通过重写<code>RequestHandler.get_login_url</code>进行自定义</li></ul></li><li>Template settings<ul><li><code>template_path</code>：包含template文件的路径</li></ul></li><li>Static file settings<ul><li><code>static_path</code>：静态文件所在文件夹</li><li><code>static_url_prefix</code>：静态文件的url前缀</li></ul></li></ul><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>一个将URLSpec list传入<code>Application</code>进行配置的栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app = Application([</span><br><span class="line">    url(<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    url(<span class="string">r&quot;/story/([0-9]+)&quot;</span>, StoryHandler, <span class="built_in">dict</span>(db=db), name=<span class="string">&quot;story&quot;</span>)</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>我们还可以加入自己的settings</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">settings = <span class="built_in">dict</span>(...)</span><br><span class="line">app = Application([</span><br><span class="line">    url(<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    url(<span class="string">r&quot;/story/([0-9]+)&quot;</span>, StoryHandler, <span class="built_in">dict</span>(db=db), name=<span class="string">&quot;story&quot;</span>)</span><br><span class="line">    ],settings)</span><br></pre></td></tr></table></figure><h3 id="RequestHandler子类"><a href="#RequestHandler子类" class="headerlink" title="RequestHandler子类"></a>RequestHandler子类</h3><blockquote><p>The main entry point for a handler subclass is a method named after the HTTP method being handled: <code>get()</code>, <code>post()</code>, etc. Each handler may define one or more of these methods to handle different HTTP actions.</p></blockquote><p>RequestHandler的子类主要用来处理http请求，进行对应的操作，主要需要实现的有<code>get</code>和<code>post</code>方法</p><h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><p><code>render</code>方法可以使用<code>template</code>用对应的参数进行渲染，<code>write</code>方法则不使用<code>template</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFormHandler</span>(<span class="params">tornado.web.RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.render(<span class="string">&#x27;index.html&#x27;</span>, message=file_url)</span><br></pre></td></tr></table></figure><h4 id="处理输入请求"><a href="#处理输入请求" class="headerlink" title="处理输入请求"></a>处理输入请求</h4><p><code>self.request</code>可以访问到当前的请求对象，如果是通过HTML表单格式请求的数据会被解析，且能够通过<code>get_query_argument</code>和<code>get_body_argument</code>进行访问</p><p><a href="https://tornado-zh.readthedocs.io/zh/latest/httputil.html#tornado.httputil.HTTPServerRequest">HTTPServerRequest完整属性列表</a></p><h4 id="RequestHandler的调用序列"><a href="#RequestHandler的调用序列" class="headerlink" title="RequestHandler的调用序列"></a>RequestHandler的调用序列</h4><ul><li>创建一个新的<code>RequestHandler</code></li><li>调用<code>initialize()</code>方法（还记得前面传递的参数吗）</li><li>调用<code>prepare()</code>方法</li><li>调用某个HTTP method：GET/POST/PUT</li><li>结束时调用<code>on_finish()</code>方法</li></ul><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>大概了解了<code>Application</code>以及<code>RequestHandler</code>子类之后，就可以写出一个最简单的hello world了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">tornado.web.RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span>():</span></span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([</span><br><span class="line">        (<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><h3 id="认证和安全"><a href="#认证和安全" class="headerlink" title="认证和安全"></a>认证和安全</h3><p>刚刚提到，在给<code>application</code>传递参数时，有一个选项为<code>cookie_secret</code>，该密钥是用来对cookies进行签名防止伪造的，这里提一下tornado的认证与安全，jupyterhub也会使用到</p><p>进行签名后的cookies会包含了编码后得cookie值、时间戳以及一个HMAC signature，<code>get_secure_cookie</code>方法会对其值进行验证，如果不通过则会返回<code>None</code>；若需要使用<code>cookie_secret</code>对cookie进行签名，则可以使用<code>set_secure_cookie</code>方式</p><p>在<code>RequestHandler</code>的子类，即我们自己编写的<code>Handler</code>中，有时我们需要确认实现用户认证，就需要复写请求处理函数<code>get_current_user</code>来对当前用户进行判断，比如可以基于cookie的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseHandler</span>(<span class="params">tornado.web.RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current_user</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.get_secure_cookie(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">BaseHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.current_user:</span><br><span class="line">            self.redirect(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        name = tornado.escape.xhtml_escape(self.current_user)</span><br><span class="line">        self.write(<span class="string">&quot;Hello, &quot;</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span>(<span class="params">BaseHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;Name: &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;&lt;input type=&quot;submit&quot; value=&quot;Sign in&quot;&gt;&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.set_secure_cookie(<span class="string">&quot;user&quot;</span>, self.get_argument(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">        self.redirect(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r&quot;/&quot;</span>, MainHandler),</span><br><span class="line">    (<span class="string">r&quot;/login&quot;</span>, LoginHandler),</span><br><span class="line">], cookie_secret=<span class="string">&quot;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Jupyterhub基本架构"><a href="#Jupyterhub基本架构" class="headerlink" title="Jupyterhub基本架构"></a>Jupyterhub基本架构</h2><p>对tornado应用的结构有了初步的了解后，我们可以开始对Jupyterhub的架构一探究竟了</p><p>Jupyterhub的有几个主要的组成部分</p><ul><li>hub（tornado application）</li><li>proxy：面向用户的部分，使用动态代理来调整HTTP对hub或单用户的notebook服务发送的请求</li><li>notebook server</li></ul><h3 id="Hub"><a href="#Hub" class="headerlink" title="Hub"></a>Hub</h3><blockquote><p><strong>Hub</strong> (Python/Tornado): manages user accounts, authentication, and coordinates Single User Notebook Servers using a Spawner.</p></blockquote><p>hub的主要功能：</p><ul><li>对登录用户进行认证（Authenticator）</li><li>保存用户、service等数据（Database）</li><li>为用户分配单用户notebook server（Spawner）</li></ul><h4 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h4><blockquote><p>The <strong>Authenticator</strong> is the mechanism for authorizing users to use the Hub and single user notebook servers.</p></blockquote><p>当用户进行登录时，会调用配置的<code>Authenticator</code>的<code>authenticate</code>方法对用户进行认证（例如默认使用的是<code>PAMAuthenticator</code>，其<code>authenticate</code>方法中会获取用户输入的用户名和密码进行认证，也可使用别的<code>authenticator</code>进行认证）</p><p>如果需要使用自己写的<code>authenticator</code>，写好之后，可以在<code>jupyterhub_config.py</code>文件中进行设置：</p><p><code>c.JupyterHub.authenticator_class = &#39;yourpackage:YourAuthenticator&#39;</code></p><p>要查看关于<code>Authenticator</code>的源码，可以查看一下<code>jupyterhub/jupyterhub/auth.py</code>中的内容</p><h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><blockquote><p>JupyterHub uses a database to store information about users, services, and other data needed for operating the Hub.</p></blockquote><p>话不多说，直接谷歌翻译</p><h4 id="Spawner"><a href="#Spawner" class="headerlink" title="Spawner"></a>Spawner</h4><blockquote><p>A <strong>Spawner</strong> starts each single-user notebook server</p></blockquote><p>当用户登录后，如果对应的notebook server没有启动，可以通过<code>/spawn</code>页面中的表单提交选项，利用spawner去启动notebook server（<code>Spawner.start</code>）</p><p>spawn，谷歌翻译的意思是<em>产卵</em>，可能这样会好理解一点</p><p>通过spawner启动了对应的notebook server后，会得到该server的ip以及port，将会被注册到proxy的路由表中，这样当用户下一次要使用该server的时候，proxy就会根据这个ip以及port，将该用户直接跳转到这个notebook server对应的地址，对应jupyterhub中的url格式为<code>/url/:username/:servername</code>（<a href="https://jupyterhub.readthedocs.io/en/stable/reference/urls.html#user-username-servername">jupyterhub的URL模式</a>）</p><p>当spawner启动之后，会通过<code>Spawner.poll</code>来确认spawner是不是还或者，如果返回的是<code>None</code>，就说明它依然健在，否则可能出事了</p><p>如果要停下spawner的话，可以使用<code>Spawner.stop</code></p><p>更多有关的代码可以查看<code>jupyterhub/jupyterhub/spawner.py</code>中的内容</p><p>和<code>Authenticator</code>同理，如果想要使用自己写的<code>Spawner</code>，可以通过修改配置文件<code>jupyterhub_config.py</code>来实现：</p><p>``c.JupyterHub.spawner_class = ‘yourpackage:YourSpawner’`</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><blockquote><p>the public facing part of JupyterHub that uses a dynamic proxy to route HTTP requests to the Hub and Single User Notebook Servers. configurable http proxy(node-http-proxy) is the default proxy</p></blockquote><p>还记得前面说到的启动server后会返回ip以及port并将其注册到proxy的路由表中吗，proxy是hub的与用户进行交互的部分，能够根据路由表中的信息，使用动态代理来调整HTTP对hub或单用户的notebook服务发送的请求</p><p>默认的proxy使用的是<a href="https://github.com/jupyterhub/configurable-http-proxy">configurable http proxy</a>（不知道是不是网络问题文档一直打不开我裂开来）</p><h3 id="Notebook-server"><a href="#Notebook-server" class="headerlink" title="Notebook server"></a>Notebook server</h3><blockquote><p>a dedicated, single-user, Jupyter Notebook server is started for each user on the system when the user logs in. The object that starts the single-user notebook servers is called a <strong>Spawner</strong>.</p></blockquote><p>当用户登录了之后，就会启动对应的单用户jupyterhub notebook server，对应的功能描述看看<a href="https://jupyter.org/">文档</a>吧</p><h3 id="子系统的交互"><a href="#子系统的交互" class="headerlink" title="子系统的交互"></a>子系统的交互</h3><img src="https://img-blog.csdnimg.cn/20200708202115603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTE1MzEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /><p>知道了上面三个Jupyterhub的基本组成部分（三大子系统），可以了解一下它们之间是怎么交互的啦</p><p>基本的流程大致长这个样子（建议结合上面官方的架构图进行食用）：</p><ul><li><p>hub产生proxy（可以参见源码<code>jupyterhub/jupyterhub/app.py</code>中<code>init_proxy</code>的部分），proxy默认将请求发送给hub</p></li><li><p>由于hub本质上是一个tornado application，那么从proxy中拿到的request全部都要由hub中注册的<code>requestHandler</code>的子类进行处理，例如：</p><ul><li>进行用户登录，并对用户的身份进行认证（<strong>Authenticator</strong>），用户的信息会被保存在<strong>database</strong>中</li><li>启动<strong>spawner</strong>生成<strong>notebook server</strong>，并将其注册到proxy的路由表中，等下一次要用的时候可以直接跳转到对应的server（**/user/[name]/**）</li><li>notebook server也可以通过hub中的authenticator等对用户身份进行认证等（**/api/auth**）</li></ul><p>…之类的操作</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>某些关于security settings的内容</p><h4 id="SSL-encryption"><a href="#SSL-encryption" class="headerlink" title="SSL encryption"></a>SSL encryption</h4><blockquote><p>You should not run JupyterHub without SSL encryption on a public network.</p></blockquote><p>SSL（Secure Sockets Layer）用于保障在网络上数据传输的安全，利用数据加密（Encryption）来确保数据在网络上传输过程中不会被窃取或监听</p><p>关于SSL协议的运行机制请看<a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">这篇</a></p><p>由于数据传输过程之前需要握手，网站需要向浏览器发送SSL证书，用于支持HTTPS网站的身份证明，其中包含了网站域名、证书有效期以及用于加密传输密码的公钥的信息</p><p>Jupyterhub需要使用SSL进行传输，因此需要配置SSL证书的信息，在<code>jupyterhub_config.py</code>文件中可以配置<code>ssl_key</code>以及<code>ssl_cert</code>的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.JupyterHub.ssl_key = <span class="string">&#x27;/path/to/my.key&#x27;</span></span><br><span class="line">c.JupyterHub.ssl_cert = <span class="string">&#x27;/path/to/my.cert&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="cookie-secret"><a href="#cookie-secret" class="headerlink" title="cookie secret"></a>cookie secret</h4><p><a href="https://blog.csdn.net/adley_app/article/details/80734247">关于cookie防篡改机制</a></p><blockquote><p>The cookie secret is an encryption key, used to encrypt the browser cookies which are used for authentication</p></blockquote><p>可以看出，cookie secret主要是用于对用户的cookie进行加密，同时防止用户对cookie进行篡改从而伪造成别人（还记得前面讲到的<code>Application</code>中<code>setting</code>参数中可以传入的<code>cookie_secret</code>吗，jupyterhub中也可以传入<code>cookie_secret</code>，同样也用于在<code>set_secure_cookie</code>以及<code>get_secure_cookie</code>中对用户进行认证或添加cookie）</p><p>在jupyterhub中，有三种方式可以生成和配置<code>cookie secret</code>，这里介绍其中的一种，更多的可以查看官方<a href="https://jupyterhub.readthedocs.io/en/stable/getting-started/security-basics.html?highlight=ssl#cookie-secret">介绍</a></p><p>同样还是配置<code>jupyterhub_config.py</code>文件，<code>c.JupyterHub.cookie_secret = bytes.fromhex(&#39;64 CHAR HEX STRING&#39;)</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/img/image-20210227222005582.png" alt="image-20210227222005582"></p><p>自己把之前那一张官方的架构图扩大了，希望有一点帮助吧</p><p>之后会继续写关于jupyterhub启动流程的东西，还是会扯到上面讲的很多内容</p><p>啊（懒狗叹气.jpg）</p>]]></content>
      
      
      <categories>
          
          <category> JupyterHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JupyterHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo安装+butterfly主题配置</title>
      <link href="p/c9188d2e.html"/>
      <url>p/c9188d2e.html</url>
      
        <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=2d5c8b14-1a70-4516-a004-1962b3a68783&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">hexo史上最全搭建教程</a></li><li><a href="https://blog.csdn.net/qq_31880107/article/details/86688467">windows下Hexo博客搭建过程</a></li><li><a href="https://hexo.io/docs/">hexo官方文档</a></li><li><a href="https://valine.js.org/">Valine官方文档</a></li><li><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo博客搭建之在文章中插入图片</a></li></ul><h2 id="1-Hexo安装"><a href="#1-Hexo安装" class="headerlink" title="1.Hexo安装"></a>1.Hexo安装</h2><p>需要事先安装好：</p><ul><li><p>nodejs，可以使用<code>node -v</code>查看是否已经安装</p></li><li><p>git，可以使用<code>git --version</code>查看是否已经安装</p><p>一般下载完之后还需要将其配置到系统路径中，参考<a href="https://blog.csdn.net/weixin_43803924/article/details/104606989">这一篇</a></p></li></ul><p>确保都安装好后：</p><ul><li><p>新建一个空文件夹，<code>cd</code>进去</p></li><li><p>可以右键打开<code>powershell</code>，也可以使用<code>Git Bash</code>，按顺序执行以下命令</p><ul><li><p><code>npm install -g hexo</code></p></li><li><p><code>hexo init 你的文件夹名</code></p><p>初始化成功后会显示<code>Start blogging with Hexo!</code>，同时空文件夹下会多出一个你刚刚命名的文件夹</p><p><img src="/img/image-20210222173111226.png" alt="image-20210222173111226"></p></li></ul><center>输入的是hexo init akaneovoBlog</center></li><li><p><code>cd</code>进入到新创建的文件夹中，按顺序执行以下命令</p><ul><li><code>npm install</code></li><li><code>hexo g</code>或<code>hexo generate</code></li><li><code>hexo server</code></li></ul></li><li><p>此时会显示<code>Hexo is running at http://localhost:4000/</code>，可以打开浏览器查看，若展示出默认的博客，则安装成功</p></li></ul><h2 id="2-将本地博客托管到Github上"><a href="#2-将本地博客托管到Github上" class="headerlink" title="2.将本地博客托管到Github上"></a>2.将本地博客托管到Github上</h2><p>需要更改配置文件<code>_config.yml</code>，以上面的文件夹为例，其地址为：</p><p><img src="/img/image-20210222173540149.png" alt="image-20210222173540149"></p><p>其中的<code>myBlog</code>即一开始创建的空文件夹，<code>akaneovoBlog</code>为<code>hexo init</code>时创建的文件夹，</p><p><strong>不要用txt直接打开它，最好用vscode之类的文本编辑器</strong></p><p>修改<code>_config.yml</code>文件中的<code>deploy</code>，改成图示形式：</p><p><img src="/img/image-20210222173755509.png" alt="image-20210222173755509"></p><p><strong>冒号后面记得带一个空格</strong></p><p>其中<code>repository</code>为自己的github仓库地址，也可以写成http的，但是不知道为啥我用了半天之后突然间<code>hexo d</code>就报错了，改成上面这个格式的就好了</p><p>保存之后安装<code>hexo-deployer-git</code>插件：<code>npm install hexo-deployer-git --save</code></p><p>之后每次修改本地博客并上传到github，都要执行如下代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generator # 或简写为hexo g</span><br><span class="line">hexo deploy # 或简写为hexo d</span><br></pre></td></tr></table></figure><p>如果只是在本地更改了文件在本地进行测试：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>托管到github上面之后，可以通过<code>xxx.github.io</code>查看自己的个人博客，或者通过自己和Github Pages绑定的域名进行查看</p><h2 id="3-配置butterfly主题"><a href="#3-配置butterfly主题" class="headerlink" title="3.配置butterfly主题"></a>3.配置butterfly主题</h2><p>u1s1，butterfly比之前看到的anatole功能真的多了好多，文档也多了超级多</p><p>看<a href="https://butterfly.js.org/">官方文档</a>来配置就够啦</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Pages与个人域名绑定</title>
      <link href="p/39c58ade.html"/>
      <url>p/39c58ade.html</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="https://cyclechen.me/2019/03/13/2019-03-13-setup-github-page-personal-with-godaddy/">github page 绑定 GoDaddy 的个人域名</a></p><p><strong>强烈建议先学习前置知识再开始配置！！！！！</strong>：<a href="d6f8daa2.html">DNS record相关</a></p><h2 id="1-GoDaddy买一个域名"><a href="#1-GoDaddy买一个域名" class="headerlink" title="1.GoDaddy买一个域名"></a>1.GoDaddy买一个域名</h2><p>有手就行</p><h2 id="2-github-repository配置"><a href="#2-github-repository配置" class="headerlink" title="2.github repository配置"></a>2.github repository配置</h2><h3 id="新建一个github仓库"><a href="#新建一个github仓库" class="headerlink" title="新建一个github仓库"></a>新建一个github仓库</h3><ul><li><p>命名格式为<code>[随便一个名字].github.io</code>，例如<code>akaneovo.github.io</code>（之后都是拿这个作为例子）</p></li><li><p>设置为public，不然后面的github pages没有办法选择theme</p></li><li><p>选择<code>add a README file</code></p><p><img src="/img/image-20210221222049663.png" alt="image-20210221222049663.png"></p></li></ul><h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><ul><li><p>点击<code>Settings</code>，下拉到<code>GitHub Pages</code></p></li><li><p>点击<code>Change theme</code>选择一个Jekyll theme</p><p>如果之前自己写了<code>html</code>文件之类的还是要选，不然好像会404</p></li><li><p><code>Custom domain</code>里面填自己购买的域名</p><p><img src="/img/image-20210221223140725.png" alt="image-20210221223140725.png"></p></li></ul><h2 id="3-DNS设置"><a href="#3-DNS设置" class="headerlink" title="3.DNS设置"></a>3.DNS设置</h2><ul><li><p>打开<a href="https://www.dnspod.cn注册一个账号/">https://www.dnspod.cn注册一个账号</a></p></li><li><p>选择DNS解析，把自己买的域名添加进去</p></li><li><p>会提示GoDaddy的域名服务器和腾讯云的域名服务器不一样，打开GoDaddy域名配置的地方，使用自定义域名服务器</p><p><img src="/img/image-20210221224432853.png" alt="image-20210221224432853"></p></li><li><p>两个域名都复制腾讯云提示的域名服务器的地址，然后保存</p></li><li><p>点击添加的域名，添加两条记录</p><p><img src="/imag/image-20210221224612240.png" alt="image-20210221224612240"></p><p>其中github IP可以在<a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">这里</a>获取</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>这四个随便哪一个都行</p></li><li><p>保存之后点击域名设置-&gt;域名信息-&gt;健康诊断，看一下域名解析通不通过（我这边还是301，但是不知道为啥就是可以正常访问注册的域名了）</p><p><img src="/img/image-20210221224752104.png" alt="image-20210221224752104"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> domain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GithubPages </tag>
            
            <tag> Godaddy </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
